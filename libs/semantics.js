baseSemantics = {"sources":[{"name":"Atomics","description":"Collection of Atomics necessary to evaluate all programs","uri":"semantics/atomics.json","type":"load"},{"name":"Functional","description":"Basic functional units like map,fold,scan,reduce","uri":"semantics/functional.json","type":"load"},{"name":"Documentation","description":"Documentation of basic semantic features","uri":"semantics/documentation.json","type":"load"},{"name":"Shells","description":"Definitions for specific shells","uri":"semantics/shells.json","type":"load"},{"name":"Modules","description":"Preprocess Modules","uri":"semantics/modules/math-module.json","type":"load"},{"name":"Atomics","description":"Standard implementation of atomics in Javascript","uri":"semantics/javascript/atomics.json","type":"load"},{"name":"Javascript CSP Construction for Node","description":"CSP implementation of Javascript Buggy translation for Node","uri":"semantics/javascript/js-csp-node.json","type":"load"},{"name":"Javascript CSP Construction for WebWorker","description":"CSP implementation of Javascript Buggy translation for web worker","uri":"semantics/javascript/js-csp-worker.json","type":"load"},{"name":"Atomic Documentation","description":"Documentation of atomics","uri":"semantics/documentation/atomics.json","type":"load"}],"symbols":[{"name":"Identity","connectors":[{"name":"StreamIn","type":"Input"},{"name":"StreamOut","type":"Output"}]},{"name":"Add","description":"Adds two numbers","connectors":[{"name":"Term 1","type":"Input"},{"name":"Term 2","type":"Input"},{"name":"Sum","type":"Output"}]},{"name":"Constant","connectors":[{"name":"Value","type":"Generator"}]},{"name":"Select","connectors":[{"name":"Array","type":"Input"},{"name":"Selection","type":"Output"}]},{"name":"Set","connectors":[{"name":"Array","type":"Input"},{"name":"Value","type":"Input"},{"name":"ArrayOut","type":"Output"}]},{"name":"StringToArray","connectors":[{"name":"String","type":"Input"},{"name":"Array","type":"Output"}]},{"name":"Clone","connectors":[{"name":"Stream","type":"Input"},{"name":"Stream1","type":"Output"},{"name":"Stream2","type":"Output"}]},{"name":"Serialize","connectors":[{"name":"Array","type":"Input"},{"name":"Stream","type":"Output"}]},{"name":"Deserialize","connectors":[{"name":"Stream","type":"Input"},{"name":"Array","type":"Output"}]},{"name":"SyncFirst","connectors":[{"name":"SyncValue","type":"Input"},{"name":"SyncStream","type":"Input"},{"name":"Sync","type":"Output"}]},{"name":"Last","connectors":[{"name":"Stream","type":"Input"},{"name":"Last","type":"Output"}]},{"name":"Map","connectors":[{"name":"Array","type":"Input"},{"name":"Result","type":"Output"},{"name":"ArrayStreamOut","type":"Output"},{"name":"ResultStreamIn","type":"Input"}]},{"name":"Scan","connectors":[{"name":"Initial","type":"Input"},{"name":"Array","type":"Input"},{"name":"Result","type":"Output"},{"name":"Value1Out","type":"Output"},{"name":"Value2Out","type":"Output"},{"name":"ResultStreamIn","type":"Input"}]},{"name":"Fold","connectors":[{"name":"Initial","type":"Input"},{"name":"Array","type":"Input"},{"name":"Result","type":"Output"},{"name":"Value1Out","type":"Output"},{"name":"Value2Out","type":"Output"},{"name":"ResultStreamIn","type":"Input"}]},{"name":"Input","connectors":[{"name":"Value","type":"Output","data-type":"string"}]},{"name":"Output","connectors":[{"name":"Value","type":"Input","data-type":"string"}]},{"name":"CSPLoopControl","connectors":[{"name":"Stream","type":"Input"},{"name":"Initial","type":"Input"},{"name":"OutStream","type":"Output"}]},{"name":"CSPLoopControl","connectors":[{"name":"Stream","type":"Input"},{"name":"Initial","type":"Input"},{"name":"OutStream","type":"Output"}]}],"modules":[{"name":"MathParser","matches":"Math","process-file":"semantics/modules/processing/parse-math.ls","process":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#%#[MathParser Module]\nmath = require \"mathjs\"\n\nrename = {\n  \"add\" : \"Add\",\n  \"constant\" : \"Constant\"\n}\n\nresults = {\n  \"add\" : \"Sum\",\n  \"constant\" : \"Value\"\n}\n\ninputs = {\n  \"add\" : [\"Term 1\", \"Term 2\"],\n}\n\nmath-id-counter = 0\n\nterm-to-term-name = (term) ->\n  if \"fn\" of term\n    term.fn\n  else if \"value\" of term\n    \"constant\"\n  else if \"name\" of term\n    \"input\"\n\nterm-to-meta = (term, generic) ->\n  switch term-to-term-name term\n  | \"constant\" => { Constant : { value: term.value } }\n  | \"input\"    => { is-input: true, input-of: generic.id }\n\nget-connector = (term, conn) ->\n  if conn == \"Result\"\n    results[term-to-term-name term]\n  else\n    inputs[term-to-term-name term][conn]\n\n\nterm-to-generic = (term) ->\n  if !(term.meta?) or !term.meta.isInput\n    {\n      name: rename[term.term-name]\n      id: \"math_\" + term.id\n      meta: term.meta\n    }\n\ncreate-connection = (t1, t2) ->\n  if t1.meta? && t1.meta.is-input\n    {\n      from: { generic: t1.meta.input-of, connector: t1.name  }\n      to: { generic: \"math_\" + t2.id, connector: get-connector t2, t1.connector-id}\n    }\n  else\n    {\n      from: { generic: \"math_\" + t1.id, connector: get-connector t1, \"Result\"  }\n      to: { generic: \"math_\" + t2.id, connector: get-connector t2, t1.connector-id}\n    }\n\ncreate-input = (term) ->\n  if term.meta && term.meta.is-input\n    { name: term.name, type: \"Input\" }\n\nterm-to-generic-list = (term) ->\n  if term.params?\n    subnodes = (term.params |> map -> term-to-generic-list it)\n    compact flatten (union [term-to-generic term], subnodes)\n  else\n    [term-to-generic term]\n\nterm-to-connection-list = (term) ->\n  if term.params?\n    flatten (term.params |> map ->\n      union (term-to-connection-list it), [create-connection it, term])\n  else\n    []\n\nterm-to-input-list = (term) ->\n  if term.params?\n    inputs = flatten (term.params |> map ->\n      term-to-input-list it)\n    compact union [create-input term], inputs\n  else\n    [create-input term]\n\npreprocess = (term, generic) ->\n  term.term-name = term-to-term-name term\n  term.id = math-id-counter\n  term.meta = term-to-meta term, generic\n  math-id-counter += 1\n  if term.params?\n    connector-id = 0\n    term.params |> each ->\n      it.connector-id = connector-id\n      preprocess it, generic\n      connector-id += 1\n  return term\n\nreturn (generic) ->\n  term = math.parse generic.module.term\n  term = preprocess term, generic\n\n  inputs = term-to-input-list term\n  inputs = union inputs, [{ name : \"Result\", type : \"Output\" }]\n  generics = term-to-generic-list term\n  connections = term-to-connection-list term\n  connections.push {\n    from: { generic: \"math_\" + term.id, connector: results[term.term-name] },\n    to: { generic: generic.id, connector: \"Result\" }\n  }\n\n  {\n    symbol: {\n      name : \"Math\",\n      id: generic.id\n      connectors : inputs\n    },\n    implementation: {\n      generics: generics\n      connections: connections\n    }\n  }\n"}],"meta":[],"implementations":[{"symbol":"Map","name":"Map","generics":[{"name":"Serialize","inputs":{"Array":">Map:Array"}},{"name":"Deserialize","inputs":{"Stream":">Map:ResultStreamIn"}}],"connections":[{"id":"Serialize:Stream -> Map:ArrayStreamOut","to":{"generic":"Map","connector":"ArrayStreamOut"},"from":{"generic":"Serialize","connector":"Stream"}},{"id":"Deserialize:Array -> Map:Result","to":{"generic":"Map","connector":"Result"},"from":{"generic":"Deserialize","connector":"Array"}},{"id":"Map:Array -> Serialize:Array","to":{"generic":"Serialize","connector":"Array"},"from":{"generic":"Map","connector":"Array"},"type":"Normal"},{"id":"Map:ResultStreamIn -> Deserialize:Stream","to":{"generic":"Deserialize","connector":"Stream"},"from":{"generic":"Map","connector":"ResultStreamIn"},"type":"Normal"}],"atomic":false},{"symbol":"Scan","name":"Scan","generics":[{"name":"SyncFirst","inputs":{"SyncValue":">Scan:Initial","SyncStream":">Serialize:Stream"}},{"name":"Identity","inputs":{"StreamIn":">Scan:ResultStreamIn"}},{"name":"Serialize","inputs":{"Array":">Scan:Array"}},{"name":"Deserialize","inputs":{"Stream":">Scan:ResultStreamIn"}}],"connections":[{"id":"SyncFirst:Sync -> Scan:Value1Out","to":{"generic":"Scan","connector":"Value1Out"},"from":{"generic":"SyncFirst","connector":"Sync"}},{"id":"Serialize:Stream -> Scan:Value2Out","to":{"generic":"Scan","connector":"Value2Out"},"from":{"generic":"Serialize","connector":"Stream"}},{"id":"Identity:StreamOut -> Scan:Value1Out","to":{"generic":"Scan","connector":"Value1Out"},"from":{"generic":"Identity","connector":"StreamOut"}},{"id":"Deserialize:Array -> Scan:Result","to":{"generic":"Scan","connector":"Result"},"from":{"generic":"Deserialize","connector":"Array"}},{"id":"Scan:Initial -> SyncFirst:SyncValue","to":{"generic":"SyncFirst","connector":"SyncValue"},"from":{"generic":"Scan","connector":"Initial"},"type":"Normal"},{"id":"Serialize:Stream -> SyncFirst:SyncStream","to":{"generic":"SyncFirst","connector":"SyncStream"},"from":{"generic":"Serialize","connector":"Stream"},"type":"Normal"},{"id":"Scan:ResultStreamIn -> Identity:StreamIn","to":{"generic":"Identity","connector":"StreamIn"},"from":{"generic":"Scan","connector":"ResultStreamIn"},"type":"Normal"},{"id":"Scan:Array -> Serialize:Array","to":{"generic":"Serialize","connector":"Array"},"from":{"generic":"Scan","connector":"Array"},"type":"Normal"},{"id":"Scan:ResultStreamIn -> Deserialize:Stream","to":{"generic":"Deserialize","connector":"Stream"},"from":{"generic":"Scan","connector":"ResultStreamIn"},"type":"Normal"}],"atomic":false},{"symbol":"Fold","name":"Fold","generics":[{"name":"Scan","inputs":{"Initial":">Fold:Initial","Array":">Fold:Array","ResultStreamIn":">Fold:ResultStreamIn"}},{"name":"Last","inputs":{"Stream":">Scan:Result"}}],"connections":[{"id":"Scan:Value1Out -> Fold:Value1Out","to":{"generic":"Fold","connector":"Value1Out"},"from":{"generic":"Scan","connector":"Value1Out"}},{"id":"Scan:Value2Out -> Fold:Value2Out","to":{"generic":"Fold","connector":"Value2Out"},"from":{"generic":"Scan","connector":"Value2Out"}},{"id":"Last:Last -> Fold:Result","to":{"generic":"Fold","connector":"Result"},"from":{"generic":"Last","connector":"Last"}},{"id":"Fold:Initial -> Scan:Initial","to":{"generic":"Scan","connector":"Initial"},"from":{"generic":"Fold","connector":"Initial"},"type":"Normal"},{"id":"Fold:Array -> Scan:Array","to":{"generic":"Scan","connector":"Array"},"from":{"generic":"Fold","connector":"Array"},"type":"Normal"},{"id":"Fold:ResultStreamIn -> Scan:ResultStreamIn","to":{"generic":"Scan","connector":"ResultStreamIn"},"from":{"generic":"Fold","connector":"ResultStreamIn"},"type":"Normal"},{"id":"Scan:Result -> Last:Stream","to":{"generic":"Last","connector":"Stream"},"from":{"generic":"Scan","connector":"Result"},"type":"Normal"}],"atomic":false},{"symbol":"Identity","name":"Identity","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/id.js","implementation":"{{output 'StreamOut'}} = {{input 'StreamIn'}};\n{{merge-meta 'StreamOut' 'StreamIn'}};\n"},{"symbol":"Add","name":"Add","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/add.js","implementation":"{{merge-meta 'Sum' 'Term 1'}};\n{{merge-meta 'Sum' 'Term 2'}};\n{{output 'Sum'}} = Number({{input 'Term 1'}}) + Number({{input 'Term 2'}});\n"},{"symbol":"Constant","name":"Constant","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/constant.js","implementation":"{{output 'Value'}} = {{node-meta 'Constant.value'}};\n"},{"symbol":"Select","name":"Select","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/select.js","implementation":"{{output 'Selection'}} = {{input 'Array'}}[{{node-meta 'Select.Selection'}}];\n"},{"symbol":"Set","name":"Set","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/set.js","implementation":"var inArray = {{input 'Array'}};\ninArray[{{node-meta 'Set.Selection'}}] = {{input 'Value'}};\n{{output 'ArrayOut'}} = inArray;\n"},{"symbol":"StringToArray","name":"StringToArray","description":"Parses a comma separated string.","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/string-to-array.js","implementation":"if({{input 'String'}}.length == 0){\n  {{output 'Array'}} = []\n} else {\n  {{output 'Array'}} = String({{input 'String'}}).split(',');\n}\n"},{"symbol":"Clone","name":"Clone","description":"CSP specific Clone operation","specific-to":["js-csp"],"language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/clone.js","implementation":"{{output 'Stream1'}} = {{input 'Stream'}};\n{{merge-meta 'Stream1' 'Stream'}};\n{{output 'Stream2'}} = {{input 'Stream'}};\n{{merge-meta 'Stream2' 'Stream'}};\n"},{"symbol":"Serialize","name":"Serialize","language":"javascript","atomic":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/serialize.js","implementation":"for(var i=0; i<{{input 'Array'}}.length; i++){\n  {{output 'Stream'}} = {{input 'Array'}}[i];\n  if(i == {{input 'Array'}}.length -1){\n    {{set-meta 'Stream' 'last' true}};\n  }\n  {{set-meta 'Stream' 'StreamComponent' 'i'}};\n  {{output-data 'Stream'}};\n}\n"},{"symbol":"Deserialize","name":"Deserialize","language":"javascript","atomic":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/deserialize.js","implementation":"if(!('Value' in storage)){\n  storage.Value = [];\n}\nstorage.Value.push({{input 'Stream'}});\nif({{has-meta 'Stream' 'last'}} && {{meta-query 'Stream' 'last'}} == true){\n  {{output 'Array'}} = storage.Value;\n  {{output-data 'Array'}};\n  delete storage.Value;\n}\n"},{"symbol":"SyncFirst","name":"SyncFirst","description":"CSP specific control element for handling loops initials","language":"javascript","atomic":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/sync-first.js","implementation":"if({{has-meta 'SyncStream' 'StreamComponent'}} && {{meta-query 'SyncStream' 'StreamComponent'}} == 0){\n  {{merge-meta 'Sync' 'SyncValue'}};\n  {{output 'Sync'}} = {{input 'SyncValue'}};\n  {{output-data 'Sync'}};\n}\n"},{"symbol":"Last","name":"Last","language":"javascript","atomic":true,"implementation-file":"semantics/javascript/implementation/atomics/last.js","implementation":"var arr = {{input 'Stream'}};\n{{output 'Last'}} = arr[arr.length - 1];\n"},{"symbol":"Map","name":"Native Map","description":"Map implementation using a native Javascript implementation","language":"javascript","atomic":true,"explicit-input":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/map.js","implementation":"{{input-data 'Array'}}\nfor(var i=0; i<{{input 'Array'}}.length; i++){\n  {{output 'ArrayStreamOut'}} = {{input 'Array'}}[i];\n  if(i == {{input 'Array'}}.length -1){\n    {{set-meta 'ArrayStreamOut' 'last' true}};\n  }\n  {{set-meta 'ArrayStreamOut' 'StreamComponent' 'i'}};\n  {{output-data 'ArrayStreamOut'}};\n  {{input-data 'ResultStreamIn'}};\n  {{output 'Result'}}[i] = {{input 'ResultStreamIn'}};\n}\n{{output-data 'Result'}}\n"},{"symbol":"CSPLoopControl","name":"CSPLoopControlImpl","language":"javascript","atomic":true,"explicit-input":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/csp-loop-control.js","implementation":"if(!(\"initial\" in storage)){\n  {{input-data 'Initial'}}\n  {{output 'OutStream'}} = {{input 'Initial'}};\n  {{merge-meta 'OutStream' 'Initial'}};\n  storage.initial = true;\n  {{output-data 'OutStream'}};\n}\nelse {\n  {{input-data 'Stream'}}\n  if(({{has-meta 'Stream' 'last'}}) && {{meta-query 'Stream' 'last'}} == true){\n    delete storage.initial\n    continue;\n  }\n  {{output 'OutStream'}} = {{input 'Stream'}};\n  {{merge-meta 'OutStream' 'Stream'}};\n  {{output-data 'OutStream'}};\n}\n"},{"symbol":"CSPLoopControl","name":"CSPLoopControlImpl","language":"javascript","atomic":true,"explicit-input":true,"explicit-callback":true,"implementation-file":"semantics/javascript/implementation/atomics/csp-loop-control.js","implementation":"if(!(\"initial\" in storage)){\n  {{input-data 'Initial'}}\n  {{output 'OutStream'}} = {{input 'Initial'}};\n  {{merge-meta 'OutStream' 'Initial'}};\n  storage.initial = true;\n  {{output-data 'OutStream'}};\n}\nelse {\n  {{input-data 'Stream'}}\n  if(({{has-meta 'Stream' 'last'}}) && {{meta-query 'Stream' 'last'}} == true){\n    delete storage.initial\n    continue;\n  }\n  {{output 'OutStream'}} = {{input 'Stream'}};\n  {{merge-meta 'OutStream' 'Stream'}};\n  {{output-data 'OutStream'}};\n}\n"}],"construction":[{"name":"js-csp-node","language":"javascript","target":"terminal","description":"uses CSP to build construct a javascript program with channel communication between groups","templates":[{"template":"program","file":"semantics/javascript/templates/csp/program-node.js","process":"once","template-file":"\n{{header}}\n{{atomics}}\n{{nodes}}\n{{graph}}\n{{starter}}\n"},{"template":"requires","file":"semantics/javascript/templates/csp/requires.js","process":"implementations","template-file":"},{\"js-csp\":3,\"object-merge\":13}],2:[function(require,module,exports){\n\"use strict\";\n\nvar buffers = require(\"./impl/buffers\");\nvar channels = require(\"./impl/channels\");\nvar select = require(\"./impl/select\");\nvar process = require(\"./impl/process\");\nvar timers = require(\"./impl/timers\");\n\nfunction spawn(gen, returnChannel) {\n  if (returnChannel) {\n    var ch = channels.chan(buffers.fixed(1));\n    (new process.Process(gen, function(value) {\n      process.put_then_callback(ch, value, function(ok) {\n        ch.close();\n      });\n    })).run();\n    return ch;\n  } else {\n    (new process.Process(gen)).run();\n    return null;\n  }\n};\n\nfunction go(f, args, returnChannel) {\n  var gen = f.apply(null, args);\n  return spawn(gen, returnChannel);\n};\n\nfunction chan(bufferOrNumber) {\n  var buf;\n  if (bufferOrNumber === 0) {\n    bufferOrNumber = null;\n  }\n  if (typeof bufferOrNumber === \"number\") {\n    buf = buffers.fixed(bufferOrNumber);\n  } else {\n    buf = bufferOrNumber;\n  }\n  return channels.chan(buf);\n};\n\n\nmodule.exports = {\n  buffers: {\n    fixed: buffers.fixed,\n    dropping: buffers.dropping,\n    sliding: buffers.sliding\n  },\n\n  spawn: spawn,\n  go: go,\n  chan: chan,\n  DEFAULT: select.DEFAULT,\n  CLOSED: channels.CLOSED,\n\n  put: process.put,\n  take: process.take,\n  sleep: process.sleep,\n  alts: process.alts,\n  putAsync: process.put_then_callback,\n  takeAsync: process.take_then_callback,\n\n  timeout: timers.timeout\n};\n\n},{\"./impl/buffers\":5,\"./impl/channels\":6,\"./impl/process\":8,\"./impl/select\":9,\"./impl/timers\":10}],3:[function(require,module,exports){\n\"use strict\";\n\nvar csp = require(\"./csp.core\");\nvar operations = require(\"./csp.operations\");\n\ncsp.operations = operations;\n\nmodule.exports = csp;\n\n},{\"./csp.core\":2,\"./csp.operations\":4}],4:[function(require,module,exports){\n\"use strict\";\n\nvar Box = require(\"./impl/channels\").Box;\n\nvar csp = require(\"./csp.core\"),\n    go = csp.go,\n    take = csp.take,\n    put = csp.put,\n    takeAsync = csp.takeAsync,\n    putAsync = csp.putAsync,\n    alts = csp.alts,\n    chan = csp.chan,\n    CLOSED = csp.CLOSED;\n\n\nfunction noOp(v) {\n}\n\nfunction mapFrom(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(value, handler);\n    },\n    _take: function(handler) {\n      var result = ch._take({\n        is_active: function() {\n          return handler.is_active();\n        },\n        commit: function() {\n          var take_cb = handler.commit();\n          return function(value) {\n            return take_cb(value === CLOSED ? CLOSED : f(value));\n          };\n        }\n      });\n      if (result) {\n        var value = result.value;\n        return new Box(value === CLOSED ? CLOSED : f(value));\n      } else {\n        return null;\n      }\n    }\n  };\n}\n\nfunction mapInto(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(f(value), handler);\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction filterFrom(p, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        out.close();\n        break;\n      }\n      if (p(value)) {\n        yield put(out, value);\n      }\n    }\n  });\n  return out;\n}\n\nfunction filterInto(p, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      if (p(value)) {\n        return ch._put(value, handler);\n      } else {\n        return new Box(!ch.is_closed());\n      }\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction removeFrom(p, ch) {\n  return filterFrom(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction removeInto(p, ch) {\n  return filterInto(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction* mapcat(f, src, dst) {\n  while (true) {\n    var value = yield take(src);\n    if (value === CLOSED) {\n      dst.close();\n      break;\n    } else {\n      var seq = f(value);\n      var length = seq.length;\n      for (var i = 0; i < length; i++) {\n        yield put(dst, seq[i]);\n      }\n      if (dst.is_closed()) {\n        break;\n      }\n    }\n  }\n}\n\nfunction mapcatFrom(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(mapcat, [f, ch, out]);\n  return out;\n}\n\nfunction mapcatInto(f, ch, bufferOrN) {\n  var src = chan(bufferOrN);\n  go(mapcat, [f, src, ch]);\n  return src;\n}\n\nfunction pipe(src, dst, keepOpen) {\n  go(function*() {\n    while (true) {\n      var value = yield take(src);\n      if (value === CLOSED) {\n        if (!keepOpen) {\n          dst.close();\n        }\n        break;\n      }\n      if (!(yield put(dst, value))) {\n        break;\n      }\n    }\n  });\n  return dst;\n}\n\nfunction split(p, ch, trueBufferOrN, falseBufferOrN) {\n  var tch = chan(trueBufferOrN);\n  var fch = chan(falseBufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        tch.close();\n        fch.close();\n        break;\n      }\n      yield put(p(value) ? tch : fch, value);\n    }\n  });\n  return [tch, fch];\n}\n\nfunction reduce(f, init, ch) {\n  return go(function*() {\n    var result = init;\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        return result;\n      } else {\n        result = f(result, value);\n      }\n    }\n  }, [], true);\n}\n\nfunction onto(ch, coll, keepOpen) {\n  return go(function*() {\n    var length = coll.length;\n    // FIX: Should be a generic looping interface (for...in?)\n    for (var i = 0; i < length; i++) {\n      yield put(ch, coll[i]);\n    }\n    if (!keepOpen) {\n      ch.close();\n    }\n  });\n}\n\n// TODO: Bounded?\nfunction fromColl(coll) {\n  var ch = chan(coll.length);\n  onto(ch, coll);\n  return ch;\n}\n\nfunction map(f, chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var length = chs.length;\n  // Array holding 1 round of values\n  var values = new Array(length);\n  // TODO: Not sure why we need a size-1 buffer here\n  var dchan = chan(1);\n  // How many more items this round\n  var dcount;\n  // put callbacks for each channel\n  var dcallbacks = new Array(length);\n  for (var i = 0; i < length; i ++) {\n    dcallbacks[i] = (function(i) {\n      return function(value) {\n        values[i] = value;\n        dcount --;\n        if (dcount === 0) {\n          putAsync(dchan, values.slice(0), noOp);\n        }\n      };\n    }(i));\n  }\n  go(function*() {\n    while (true) {\n      dcount = length;\n      // We could just launch n goroutines here, but for effciency we\n      // don't\n      for (var i = 0; i < length; i ++) {\n        try {\n          takeAsync(chs[i], dcallbacks[i]);\n        } catch (e) {\n          // FIX: Hmm why catching here?\n          dcount --;\n        }\n      }\n      var values = yield take(dchan);\n      for (i = 0; i < length; i ++) {\n        if (values[i] === CLOSED) {\n          out.close();\n          return;\n        }\n      }\n      yield put(out, f.apply(null, values));\n    }\n  });\n  return out;\n}\n\nfunction merge(chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var actives = chs.slice(0);\n  go(function*() {\n    while (true) {\n      if (actives.length === 0) {\n        break;\n      }\n      var r = yield alts(actives);\n      var value = r.value;\n      if (value === CLOSED) {\n        // Remove closed channel\n        var i = actives.indexOf(r.channel);\n        actives.splice(i, 1);\n        continue;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction into(coll, ch) {\n  var result = coll.slice(0);\n  return reduce(function(result, item) {\n    result.push(item);\n    return result;\n  }, result, ch);\n}\n\nfunction takeN(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    for (var i = 0; i < n; i ++) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nvar NOTHING = {};\n\nfunction unique(ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      if (value === last) {\n        continue;\n      }\n      last = value;\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction partitionBy(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var part = [];\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        if (part.length > 0) {\n          yield put(out, part);\n        }\n        out.close();\n        break;\n      } else {\n        var newItem = f(value);\n        if (newItem === last || last === NOTHING) {\n          part.push(value);\n        } else {\n          yield put(out, part);\n          part = [value];\n        }\n        last = newItem;\n      }\n    }\n  });\n  return out;\n}\n\nfunction partition(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var part = new Array(n);\n      for (var i = 0; i < n; i++) {\n        var value = yield take(ch);\n        if (value === CLOSED) {\n          if (i > 0) {\n            yield put(out, part.slice(0, i));\n          }\n          out.close();\n          return;\n        }\n        part[i] = value;\n      }\n      yield put(out, part);\n    }\n  });\n  return out;\n}\n\n// For channel identification\nvar genId = (function() {\n  var i = 0;\n  return function() {\n    i ++;\n    return \"\" + i;\n  };\n})();\n\nvar ID_ATTR = \"__csp_channel_id\";\n\n// TODO: Do we need to check with hasOwnProperty?\nfunction len(obj) {\n  var count = 0;\n  for (var p in obj) {\n    count ++;\n  }\n  return count;\n}\n\nfunction chanId(ch) {\n  var id = ch[ID_ATTR];\n  if (id === undefined) {\n    id = ch[ID_ATTR] = genId();\n  }\n  return id;\n}\n\nvar Mult = function(ch) {\n  this.taps = {};\n  this.ch = ch;\n};\n\nvar Tap = function(channel, keepOpen) {\n  this.channel = channel;\n  this.keepOpen = keepOpen;\n};\n\nMult.prototype.muxch = function() {\n  return this.ch;\n};\n\nMult.prototype.tap = function(ch, keepOpen) {\n  var id = chanId(ch);\n  this.taps[id] = new Tap(ch, keepOpen);\n};\n\nMult.prototype.untap = function(ch) {\n  delete this.taps[chanId(ch)];\n};\n\nMult.prototype.untapAll = function() {\n  this.taps = {};\n};\n\nfunction mult(ch) {\n  var m = new Mult(ch);\n  var dchan = chan(1);\n  var dcount;\n  function makeDoneCallback(tap) {\n    return function(stillOpen) {\n      dcount --;\n      if (dcount === 0) {\n        putAsync(dchan, true, noOp);\n      }\n      if (!stillOpen) {\n        m.untap(tap.channel);\n      }\n    };\n  }\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var id, t;\n      var taps = m.taps;\n      if (value === CLOSED) {\n        for (id in taps) {\n          t = taps[id];\n          if (!t.keepOpen) {\n            t.channel.close();\n          }\n        }\n        // TODO: Is this necessary?\n        m.untapAll();\n        break;\n      }\n      dcount = len(taps);\n      // XXX: This is because putAsync can actually call back\n      // immediately. Fix that\n      var initDcount = dcount;\n      // Put value on tapping channels...\n      for (id in taps) {\n        t = taps[id];\n        putAsync(t.channel, value, makeDoneCallback(t));\n      }\n      // ... waiting for all puts to complete\n      if (initDcount > 0) {\n        yield take(dchan);\n      }\n    }\n  });\n  return m;\n}\n\nmult.tap = function tap(m, ch, keepOpen) {\n  m.tap(ch, keepOpen);\n  return ch;\n};\n\nmult.untap = function untap(m, ch) {\n  m.untap(ch);\n};\n\nmult.untapAll = function untapAll(m) {\n  m.untapAll();\n};\n\nfunction constantlyNull() {\n  return null;\n}\n\nvar Pub = function(ch, topicFn, bufferFn) {\n  this.ch = ch;\n  this.topicFn = topicFn;\n  this.bufferFn = bufferFn;\n  this.mults = {};\n};\n\nPub.prototype._ensureMult = function(topic) {\n  var m = this.mults[topic];\n  var bufferFn = this.bufferFn;\n  if (!m) {\n    m = this.mults[topic] = mult(chan(bufferFn(topic)));\n  }\n  return m;\n};\n\nPub.prototype.sub = function(topic, ch, keepOpen) {\n  var m = this._ensureMult(topic);\n  return mult.tap(m, ch, keepOpen);\n};\n\nPub.prototype.unsub = function(topic, ch) {\n  var m = this.mults[topic];\n  if (m) {\n    mult.untap(m, ch);\n  }\n};\n\nPub.prototype.unsubAll = function(topic) {\n  if (topic === undefined) {\n    this.mults = {};\n  } else {\n    delete this.mults[topic];\n  }\n};\n\nfunction pub(ch, topicFn, bufferFn) {\n  bufferFn = bufferFn || constantlyNull;\n  var p = new Pub(ch, topicFn, bufferFn);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var mults = p.mults;\n      var topic;\n      if (value === CLOSED) {\n        for (topic in mults) {\n          mults[topic].muxch().close();\n        }\n        break;\n      }\n      // TODO: Somehow ensure/document that this must return a string\n      // (otherwise use proper (hash)maps)\n      topic = topicFn(value);\n      var m = mults[topic];\n      if (m) {\n        var stillOpen = yield put(m.muxch(), value);\n        if (!stillOpen) {\n          delete mults[topic];\n        }\n      }\n    }\n  });\n  return p;\n}\n\npub.sub = function sub(p, topic, ch, keepOpen) {\n  return p.sub(topic, ch, keepOpen);\n};\n\npub.unsub = function unsub(p, topic, ch) {\n  p.unsub(topic, ch);\n};\n\npub.unsubAll = function unsubAll(p, topic) {\n  p.unsubAll(topic);\n};\n\nmodule.exports = {\n  mapFrom: mapFrom,\n  mapInto: mapInto,\n  filterFrom: filterFrom,\n  filterInto: filterInto,\n  removeFrom: removeFrom,\n  removeInto: removeInto,\n  mapcatFrom: mapcatFrom,\n  mapcatInto: mapcatInto,\n\n  pipe: pipe,\n  split: split,\n  reduce: reduce,\n  onto: onto,\n  fromColl: fromColl,\n\n  map: map,\n  merge: merge,\n  into: into,\n  take: takeN,\n  unique: unique,\n  partition: partition,\n  partitionBy: partitionBy\n};\n\n\n// Possible \"fluid\" interfaces:\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc],\n//   [into, []]\n// )\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc, _],\n//   [into, [], _]\n// )\n\n// wrap()\n//   .fromColl([1, 2, 3, 4])\n//   .mapFrom(inc)\n//   .into([])\n//   .unwrap();\n\n},{\"./csp.core\":2,\"./impl/channels\":6}],5:[function(require,module,exports){\n\"use strict\";\n\n// TODO: Consider EmptyError & FullError to avoid redundant bound\n// checks, to improve performance (may need benchmarks)\n\nfunction acopy(src, src_start, dst, dst_start, length) {\n  var count = 0;\n  while (true) {\n    if (count >= length) {\n      break;\n    }\n    dst[dst_start + count] = src[src_start + count];\n    count ++;\n  }\n}\n\nvar EMPTY = {\n  toString: function() {\n    return \"[object EMPTY]\";\n  }\n};\n\nvar RingBuffer = function(head, tail, length, array) {\n  this.length = length;\n  this.array = array;\n  this.head = head;\n  this.tail = tail;\n};\n\n// Internal method, callers must do bound check\nRingBuffer.prototype._unshift = function(item) {\n  var array = this.array;\n  var head = this.head;\n  array[head] = item;\n  this.head = (head + 1) % array.length;\n  this.length ++;\n};\n\nRingBuffer.prototype._resize = function() {\n  var array = this.array;\n  var new_length = 2 * array.length;\n  var new_array = new Array(new_length);\n  var head = this.head;\n  var tail = this.tail;\n  var length = this.length;\n  if (tail < head) {\n    acopy(array, tail, new_array, 0, length);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail > head) {\n    acopy(array, tail, new_array, 0, array.length - tail);\n    acopy(array, 0, new_array, array.length - tail, head);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail === head) {\n    this.tail = 0;\n    this.head = 0;\n    this.array = new_array;\n  }\n};\n\nRingBuffer.prototype.unbounded_unshift = function(item) {\n  if (this.length + 1 === this.array.length) {\n    this._resize();\n  }\n  this._unshift(item);\n};\n\nRingBuffer.prototype.pop = function() {\n  if (this.length === 0) {\n    return EMPTY;\n  }\n  var array = this.array;\n  var tail = this.tail;\n  var item = array[tail];\n  array[tail] = null;\n  this.tail = (tail + 1) % array.length;\n  this.length --;\n  return item;\n};\n\nRingBuffer.prototype.cleanup = function(predicate) {\n  var length = this.length;\n  for (var i = 0; i < length; i++) {\n    var item = this.pop();\n    if (predicate(item)) {\n      this._unshift(item);\n    }\n  }\n};\n\n\nvar FixedBuffer = function(buf,  n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nFixedBuffer.prototype.is_full = function() {\n  return this.buf.length == this.n;\n};\n\nFixedBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nFixedBuffer.prototype.add = function(item) {\n  if (this.is_full()) {\n    throw new Error(\"Can't add to a full buffer\");\n  }\n  this.buf._unshift(item);\n};\n\nFixedBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar DroppingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nDroppingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nDroppingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nDroppingBuffer.prototype.add = function(item) {\n  if (this.buf.length < this.n) {\n    this.buf._unshift(item);\n  }\n};\n\nDroppingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar SlidingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nSlidingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nSlidingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nSlidingBuffer.prototype.add = function(item) {\n  if (this.buf.length === this.n) {\n    this.buf.pop();\n  }\n  this.buf._unshift(item);\n};\n\nSlidingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar ring = exports.ring = function ring_buffer(n) {\n  return new RingBuffer(0, 0, 0, new Array(n));\n};\n\nexports.fixed = function fixed_buffer(n) {\n  return new FixedBuffer(ring(n), n);\n};\n\nexports.dropping = function dropping_buffer(n) {\n  return new DroppingBuffer(ring(n), n);\n};\n\nexports.sliding = function sliding_buffer(n) {\n  return new SlidingBuffer(ring(n), n);\n};\n\nexports.EMPTY = EMPTY;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nvar buffers = require(\"./buffers\");\nvar dispatch = require(\"./dispatch\");\n\nvar MAX_DIRTY = 64;\nvar MAX_QUEUE_SIZE = 1024;\n\nvar CLOSED = null;\n\nvar Box = function(value) {\n  this.value = value;\n};\n\nvar PutBox = function(handler, value) {\n  this.handler = handler;\n  this.value = value;\n};\n\nvar Channel = function(takes, puts, buf) {\n  this.buf = buf;\n  this.takes = takes;\n  this.puts = puts;\n\n  this.dirty_takes = 0;\n  this.dirty_puts = 0;\n  this.closed = false;\n};\n\nChannel.prototype._put = function(value, handler) {\n  if (value === CLOSED) {\n    throw new Error(\"Cannot put CLOSED on a channel.\");\n  }\n\n  if (this.closed || !handler.is_active()) {\n    return new Box(!this.closed);\n  }\n\n  while (true) {\n    var taker = this.takes.pop();\n    if (taker !== buffers.EMPTY) {\n      if (taker.is_active()) {\n        var callback = taker.commit();\n        handler.commit();\n        dispatch.run(function() {\n          callback(value);\n        });\n        return new Box(true);\n      } else {\n        continue;\n      }\n    } else {\n      if (this.buf && !this.buf.is_full()) {\n        handler.commit();\n        this.buf.add(value);\n        return new Box(true);\n      } else {\n        if (this.dirty_puts > MAX_DIRTY) {\n          this.puts.cleanup(function(putter) {\n            return putter.handler.is_active();\n          });\n          this.dirty_puts = 0;\n        } else {\n          this.dirty_puts ++;\n        }\n        if (this.puts.length >= MAX_QUEUE_SIZE) {\n          throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending puts are allowed on a single channel.\");\n        }\n        this.puts.unbounded_unshift(new PutBox(handler, value));\n      }\n    }\n    break;\n  }\n\n  return null;\n};\n\nChannel.prototype._take = function(handler) {\n  if (!handler.is_active()) {\n    return null;\n  }\n\n  var putter, put_handler, callback;\n\n  if (this.buf && this.buf.count() > 0) {\n    handler.commit();\n    var value = this.buf.remove();\n    // We need to check pending puts here, other wise they won't\n    // be able to proceed until their number reaches MAX_DIRTY\n    while (true) {\n      putter = this.puts.pop();\n      if (putter !== buffers.EMPTY) {\n        put_handler = putter.handler;\n        if (put_handler.is_active()) {\n          callback = put_handler.commit();\n          dispatch.run(function() {\n            callback(true);\n          });\n          this.buf.add(putter.value);\n          break;\n        } else {\n          continue;\n        }\n      }\n      break;\n    }\n    return new Box(value);\n  }\n\n  while (true) {\n    putter = this.puts.pop();\n    if (putter !== buffers.EMPTY) {\n      put_handler = putter.handler;\n      if (put_handler.is_active()) {\n        handler.commit();\n        callback = put_handler.commit();\n        dispatch.run(function() {\n          callback(true);\n        });\n        return new Box(putter.value);\n      } else {\n        continue;\n      }\n    } else {\n      if (this.closed) {\n        handler.commit();\n        return new Box(CLOSED);\n      } else {\n        if (this.dirty_takes > MAX_DIRTY) {\n          this.takes.cleanup(function(handler) {\n            return handler.is_active();\n          });\n          this.dirty_takes = 0;\n        } else {\n          this.dirty_takes ++;\n        }\n        if (this.takes.length >= MAX_QUEUE_SIZE) {\n          throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending takes are allowed on a single channel.\");\n        }\n        this.takes.unbounded_unshift(handler);\n      }\n    }\n    break;\n  }\n\n  return null;\n};\n\nChannel.prototype.close = function() {\n  if (this.closed) {\n    return;\n  }\n  this.closed = true;\n  while (true) {\n    var taker = this.takes.pop();\n    if (taker === buffers.EMPTY) {\n      break;\n    }\n    if (taker.is_active()) {\n      var callback = taker.commit();\n      dispatch.run(function() {\n        callback(CLOSED);\n      });\n    }\n  }\n  // TODO: Tests\n  while (true) {\n    var putter = this.puts.pop();\n    if (putter === buffers.EMPTY) {\n      break;\n    }\n    if (putter.handler.is_active()) {\n      var put_callback = putter.handler.commit();\n      dispatch.run(function() {\n        put_callback(false);\n      });\n    }\n  }\n};\n\n\nChannel.prototype.is_closed = function() {\n  return this.closed;\n};\n\n\nexports.chan = function(buf) {\n  return new Channel(buffers.ring(32), buffers.ring(32), buf);\n};\n\nexports.Box = Box;\n\nexports.CLOSED = CLOSED;\n\n},{\"./buffers\":5,\"./dispatch\":7}],7:[function(require,module,exports){\n\"use strict\";\n\n// TODO: Use process.nextTick if it's available since it's more\n// efficient\n// http://howtonode.org/understanding-process-next-tick\n// Maybe we don't even need to queue ourselves in that case?\n\n// XXX: But http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/\n// Looks like it will blow up the stack (or is that just about\n// pre-empting IO (but that's already bad enough IMO)?)\n\n// Looks like\n// http://nodejs.org/api/process.html#process_process_nexttick_callback\n// is the equivalent of our TASK_BATCH_SIZE\n\nvar buffers = require(\"./buffers\");\n\nvar TASK_BATCH_SIZE = 1024;\n\nvar tasks = buffers.ring(32);\nvar running = false;\nvar queued = false;\n\nvar queue_dispatcher;\n\nfunction process_messages() {\n  running = true;\n  queued = false;\n  var count = 0;\n  while (true) {\n    var task = tasks.pop();\n    if (task === buffers.EMPTY) {\n      break;\n    }\n    // TODO: Don't we need a try/finally here?\n    task();\n    if (count >= TASK_BATCH_SIZE) {\n      break;\n    }\n    count ++;\n  }\n  running = false;\n  if (tasks.length > 0) {\n    queue_dispatcher();\n  }\n}\n\nif (typeof MessageChannel !== \"undefined\") {\n  var message_channel = new MessageChannel();\n  message_channel.port1.onmessage = function(_) {\n    process_messages();\n  };\n  queue_dispatcher = function()  {\n    if (!(queued && running)) {\n      queued = true;\n      message_channel.port2.postMessage(0);\n    }\n  };\n} else if (typeof setImmediate !== \"undefined\") {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setImmediate(process_messages);\n    }\n  };\n} else {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setTimeout(process_messages, 0);\n    }\n  };\n}\n\nexports.run = function (f) {\n  tasks.unbounded_unshift(f);\n  queue_dispatcher();\n};\n\nexports.queue_delay = function(f, delay) {\n  setTimeout(f, delay);\n};\n\n},{\"./buffers\":5}],8:[function(require,module,exports){\n\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar select = require(\"./select\");\n\nvar FnHandler = function(f) {\n  this.f = f;\n};\n\nFnHandler.prototype.is_active = function() {\n  return true;\n};\n\nFnHandler.prototype.commit = function() {\n  return this.f;\n};\n\nfunction put_then_callback(channel, value, callback) {\n  var result = channel._put(value, new FnHandler(callback));\n  if (result) {\n    callback(result.value);\n  }\n}\n\nfunction take_then_callback(channel, callback) {\n  var result = channel._take(new FnHandler(callback));\n  if (result) {\n    callback(result.value);\n  }\n}\n\nvar Process = function(gen, onFinish) {\n  this.gen = gen;\n  this.finished = false;\n  this.onFinish = onFinish;\n};\n\nvar Instruction = function(op, data) {\n  this.op = op;\n  this.data = data;\n};\n\nvar TAKE = \"take\";\nvar PUT = \"put\";\nvar SLEEP = \"sleep\";\nvar ALTS = \"alts\";\n\n// TODO FIX XXX: This is a (probably) temporary hack to avoid blowing\n// up the stack, but it means double queueing when the value is not\n// immediately available\nProcess.prototype._continue = function(response) {\n  var self = this;\n  dispatch.run(function() {\n    self.run(response);\n  });\n};\n\nProcess.prototype._done = function(value) {\n  if (!this.finished) {\n    this.finished = true;\n    var onFinish = this.onFinish;\n    if (typeof onFinish === \"function\") {\n      dispatch.run(function() {\n        onFinish(value);\n      });\n    }\n  }\n};\n\nProcess.prototype.run = function(response) {\n  if (this.finished) {\n    return;\n  }\n\n  // TODO: Shouldn't we (optionally) stop error propagation here (and\n  // signal the error through a channel or something)? Otherwise the\n  // uncaught exception will crash some runtimes (e.g. Node)\n  var iter = this.gen.next(response);\n  if (iter.done) {\n    this._done(iter.value);\n    return;\n  }\n\n  var ins = iter.value;\n\n  if (ins instanceof Instruction) {\n    var self = this;\n    switch (ins.op) {\n    case PUT:\n      var data = ins.data;\n      put_then_callback(data.channel, data.value, function(ok) {\n        self._continue(ok);\n      });\n      break;\n\n    case TAKE:\n      var channel = ins.data;\n      take_then_callback(channel, function(value) {\n        self._continue(value);\n      });\n      break;\n\n    case SLEEP:\n      var msecs = ins.data;\n      dispatch.queue_delay(function() {\n        self.run(null);\n      }, msecs);\n      break;\n\n    case ALTS:\n      select.do_alts(ins.data.operations, function(result) {\n        self._continue(result);\n      }, ins.data.options);\n      break;\n    }\n  } else {\n    this._continue(ins);\n  }\n};\n\nfunction take(channel) {\n  return new Instruction(TAKE, channel);\n}\n\nfunction put(channel, value) {\n  return new Instruction(PUT, {\n    channel: channel,\n    value: value\n  });\n}\n\nfunction sleep(msecs) {\n  return new Instruction(SLEEP, msecs);\n}\n\nfunction alts(operations, options) {\n  return new Instruction(ALTS, {\n    operations: operations,\n    options: options\n  });\n}\n\nexports.put_then_callback = put_then_callback;\nexports.take_then_callback = take_then_callback;\nexports.put = put;\nexports.take = take;\nexports.sleep = sleep;\nexports.alts = alts;\n\nexports.Process = Process;\n\n},{\"./dispatch\":7,\"./select\":9}],9:[function(require,module,exports){\n\"use strict\";\n\nvar Box = require(\"./channels\").Box;\n\nvar AltHandler = function(flag, f) {\n  this.f = f;\n  this.flag = flag;\n};\n\nAltHandler.prototype.is_active = function() {\n  return this.flag.value;\n};\n\nAltHandler.prototype.commit = function() {\n  this.flag.value = false;\n  return this.f;\n};\n\nvar AltResult = function(value, channel) {\n  this.value = value;\n  this.channel = channel;\n};\n\nfunction rand_int(n) {\n  return Math.floor(Math.random() * (n + 1));\n}\n\nfunction random_array(n) {\n  var a = new Array(n);\n  var i;\n  for (i = 0; i < n; i++) {\n    a[i] = 0;\n  }\n  for (i = 1; i < n; i++) {\n    var j = rand_int(i);\n    a[i] = a[j];\n    a[j] = i;\n  }\n  return a;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar DEFAULT = {\n  toString: function() {\n    return \"[object DEFAULT]\";\n  }\n};\n\n// TODO: Accept a priority function or something\nexports.do_alts = function(operations, callback, options) {\n  var length = operations.length;\n  // XXX Hmm\n  if (length === 0) {\n    throw new Error(\"Empty alt list\");\n  }\n\n  var priority = (options && options.priority) ? true : false;\n  if (!priority) {\n    var indexes = random_array(length);\n  }\n\n  var flag = new Box(true);\n\n  for (var i = 0; i < length; i++) {\n    var operation = operations[priority ? i : indexes[i]];\n    var port, result;\n    // XXX Hmm\n    if (operation instanceof Array) {\n      var value = operation[1];\n      port = operation[0];\n      result = port._put(value, (function(port) {\n        return new AltHandler(flag, function(ok) {\n          callback(new AltResult(ok, port));\n        });\n      })(port));\n    } else {\n      port = operation;\n      result = port._take((function(port) {\n        return new AltHandler(flag, function(value) {\n          callback(new AltResult(value, port));\n        });\n      })(port));\n    }\n    // XXX Hmm\n    if (result instanceof Box) {\n      callback(new AltResult(result.value, port));\n      break;\n    }\n  }\n\n  if (!(result instanceof Box)\n      && options\n      && hasOwnProperty.call(options, \"default\")) {\n    if (flag.value) {\n      flag.value = false;\n      callback(new AltResult(options[\"default\"], DEFAULT));\n    }\n  }\n};\n\nexports.DEFAULT = DEFAULT;\n\n},{\"./channels\":6}],10:[function(require,module,exports){\n\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar channels = require(\"./channels\");\n\nexports.timeout = function timeout_channel(msecs) {\n  var chan = channels.chan();\n  dispatch.queue_delay(function() {\n    chan.close();\n  }, msecs);\n  return chan;\n};\n\n},{\"./channels\":6,\"./dispatch\":7}],11:[function(require,module,exports){\n/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\r\n/*jslint\r\n    evil: true,\r\n    node: true\r\n*/\r\n'use strict';\r\n/**\r\n * Clones non native JavaScript functions, or references native functions.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {Function} func The function to clone.\r\n * @returns {Function} Returns a clone of the non native function, or a\r\n *  reference to the native function.\r\n */\r\nfunction cloneFunction(func) {\r\n    var out, str;\r\n    try {\r\n        str = func.toString();\r\n        if (/\\[native code\\]/.test(str)) {\r\n            out = func;\r\n        } else {\r\n            out = eval('(function(){return ' + str + '}());');\r\n        }\r\n    } catch (e) {\r\n        throw new Error(e.message + '\\r\\n\\r\\n' + str);\r\n    }\r\n    return out;\r\n}\r\nmodule.exports = cloneFunction;\n},{}],12:[function(require,module,exports){\n/**\r\n * Executes a function on each of an objects own enumerable properties. The\r\n *  callback function will receive three arguments: the value of the current\r\n *  property, the name of the property, and the object being processed. This is\r\n *  roughly equivalent to the signature for callbacks to\r\n *  Array.prototype.forEach.\r\n * @param {Object} obj The object to act on.\r\n * @param {Function} callback The function to execute.\r\n * @returns {Object} Returns the given object.\r\n */\r\nfunction objectForeach(obj, callback) {\r\n    \"use strict\";\r\n    Object.keys(obj).forEach(function (prop) {\r\n        callback(obj[prop], prop, obj);\r\n    });\r\n    return obj;\r\n};\r\nmodule.exports = objectForeach;\n},{}],13:[function(require,module,exports){\n/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\r\n/*jslint\r\n    white: true,\r\n    vars: true,\r\n    node: true\r\n*/\r\nfunction ObjectMergeOptions(opts) {\r\n    'use strict';\r\n    opts = opts || {};\r\n    this.depth = opts.depth || false;\r\n    // circular ref check is true unless explicitly set to false\r\n    // ignore the jslint warning here, it's pointless.\r\n    this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\r\n}\r\n/*jslint unparam:true*/\r\n/**\r\n * Creates a new options object suitable for use with objectMerge.\r\n * @memberOf objectMerge\r\n * @param {Object} [opts] An object specifying the options.\r\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\r\n *  during merging. If this is set to false then there will be no depth limit.\r\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\r\n *  errors on circular references.\r\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\r\n *  to be used with objectMerge.\r\n * @example\r\n *  var opts = objectMerge.createOptions({\r\n *      depth : 2,\r\n *      throwOnCircularRef : false\r\n *  });\r\n *  var obj1 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : {}\r\n *          }\r\n *      }\r\n *  };\r\n *  var obj2 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : 'will not be in output'\r\n *          },\r\n *          a22 : {}\r\n *      }\r\n *  };\r\n *  objectMerge(opts, obj1, obj2);\r\n */\r\nfunction createOptions(opts) {\r\n    'use strict';\r\n    var argz = Array.prototype.slice.call(arguments, 0);\r\n    argz.unshift(null);\r\n    var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\r\n    return new F();\r\n}\r\n/*jslint unparam:false*/\r\n/**\r\n * Merges JavaScript objects recursively without altering the objects merged.\r\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {ObjectMergeOptions} [opts] An options object created by\r\n *  objectMerge.createOptions. Options must be specified as the first argument\r\n *  and must be an object created with createOptions or else the object will\r\n *  not be recognized as an options object and will be merged instead.\r\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\r\n *  argument given will be treated as an object to merge. Each object\r\n *  overwrites the previous objects descendant properties if the property name\r\n *  matches. If objects properties are objects they will be merged recursively\r\n *  as well.\r\n * @returns {Object} Returns a single merged object composed from clones of the\r\n *  input objects.\r\n * @example\r\n *  var objectMerge = require('object-merge');\r\n *  var x = {\r\n *      a : 'a',\r\n *      b : 'b',\r\n *      c : {\r\n *          d : 'd',\r\n *          e : 'e',\r\n *          f : {\r\n *              g : 'g'\r\n *          }\r\n *      }\r\n *  };\r\n *  var y = {\r\n *      a : '`a',\r\n *      b : '`b',\r\n *      c : {\r\n *          d : '`d'\r\n *      }\r\n *  };\r\n *  var z = {\r\n *      a : {\r\n *          b : '``b'\r\n *      },\r\n *      fun : function foo () {\r\n *          return 'foo';\r\n *      },\r\n *      aps : Array.prototype.slice\r\n *  };\r\n *  var out = objectMerge(x, y, z);\r\n *  // out.a will be {\r\n *  //         b : '``b'\r\n *  //     }\r\n *  // out.b will be '`b'\r\n *  // out.c will be {\r\n *  //         d : '`d',\r\n *  //         e : 'e',\r\n *  //         f : {\r\n *  //             g : 'g'\r\n *  //         }\r\n *  //     }\r\n *  // out.fun will be a clone of z.fun\r\n *  // out.aps will be equal to z.aps\r\n */\r\nfunction objectMerge(shadows) {\r\n    'use strict';\r\n    var objectForeach = require('object-foreach');\r\n    var cloneFunction = require('clone-function');\r\n    // this is the queue of visited objects / properties.\r\n    var visited = [];\r\n    // various merge options\r\n    var options = {};\r\n    // gets the sequential trailing objects from array.\r\n    function getShadowObjects(shadows) {\r\n        var out = shadows.reduce(function (collector, shadow) {\r\n                if (shadow instanceof Object) {\r\n                    collector.push(shadow);\r\n                } else {\r\n                    collector = [];\r\n                }\r\n                return collector;\r\n            }, []);\r\n        return out;\r\n    }\r\n    // gets either a new object of the proper type or the last primitive value\r\n    function getOutputObject(shadows) {\r\n        var out;\r\n        var lastShadow = shadows[shadows.length - 1];\r\n        if (lastShadow instanceof Array) {\r\n            out = [];\r\n        } else if (lastShadow instanceof Function) {\r\n            try {\r\n                out = cloneFunction(lastShadow);\r\n            } catch (e) {\r\n                throw new Error(e.message);\r\n            }\r\n        } else if (lastShadow instanceof Object) {\r\n            out = {};\r\n        } else {\r\n            // lastShadow is a primitive value;\r\n            out = lastShadow;\r\n        }\r\n        return out;\r\n    }\r\n    // checks for circular references\r\n    function circularReferenceCheck(shadows) {\r\n        // if any of the current objects to process exist in the queue\r\n        // then throw an error.\r\n        shadows.forEach(function (item) {\r\n            if (item instanceof Object && visited.indexOf(item) > -1) {\r\n                throw new Error('Circular reference error');\r\n            }\r\n        });\r\n        // if none of the current objects were in the queue\r\n        // then add references to the queue.\r\n        visited = visited.concat(shadows);\r\n    }\r\n    function objectMergeRecursor(shadows, currentDepth) {\r\n        if (options.depth !== false) {\r\n            currentDepth = currentDepth ? currentDepth + 1 : 1;\r\n        } else {\r\n            currentDepth = 0;\r\n        }\r\n        if (options.throwOnCircularRef === true) {\r\n            circularReferenceCheck(shadows);\r\n        }\r\n        var out = getOutputObject(shadows);\r\n        /*jslint unparam: true */\r\n        function shadowHandler(val, prop, shadow) {\r\n            if (out[prop]) {\r\n                out[prop] = objectMergeRecursor([\r\n                    out[prop],\r\n                    shadow[prop]\r\n                ], currentDepth);\r\n            } else {\r\n                out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\r\n            }\r\n        }\r\n        /*jslint unparam:false */\r\n        function shadowMerger(shadow) {\r\n            objectForeach(shadow, shadowHandler);\r\n        }\r\n        // short circuits case where output would be a primitive value\r\n        // anyway.\r\n        if (out instanceof Object && currentDepth <= options.depth) {\r\n            // only merges trailing objects since primitives would wipe out\r\n            // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\r\n            // would result in {b:'b'} so the first two arguments\r\n            // can be ignored completely.\r\n            var relevantShadows = getShadowObjects(shadows);\r\n            relevantShadows.forEach(shadowMerger);\r\n        }\r\n        return out;\r\n    }\r\n    // determines whether an options object was passed in and\r\n    // uses it if present\r\n    // ignore the jslint warning here too.\r\n    if (arguments[0] instanceof ObjectMergeOptions) {\r\n        options = arguments[0];\r\n        shadows = Array.prototype.slice.call(arguments, 1);\r\n    } else {\r\n        options = createOptions();\r\n        shadows = Array.prototype.slice.call(arguments, 0);\r\n    }\r\n    return objectMergeRecursor(shadows);\r\n}\r\nobjectMerge.createOptions = createOptions;\r\nmodule.exports = objectMerge;\n},{\"clone-function\":11,\"object-foreach\":12}]},{},[1]);\n"},{"template":"header","file":"semantics/javascript/templates/csp/header.js","process":"once","template-file":"var csp = require(\"js-csp\");\nvar merge = require(\"object-merge\");\n\nfunction* id(input, out){\n  while(true)\n  {\n    var taken = yield csp.take(input);\n    yield csp.put(out, taken);\n  }\n}\n\n{{~#if debug}}\n// map id -> array of things not taken\nvar notTaken = {};\nvar outInMap = {};\nfunction debug_put(id, what){\n  if(id in notTaken){\n    notTaken[id].push(what);\n  } else {\n    notTaken[id] = [what];\n  }\n}\n\nfunction debug_take_pre(id){\n  var newID = outInMap[id];\n  notTaken[newID][0].taken = true;\n}\nfunction debug_take_post(id){\n  var newID = outInMap[id];\n  notTaken[newID] = notTaken[newID].slice(1);\n}\n{{~/if}}\nfunction* outputData(id, chan, what){\n{{~#if debug}}\n  debug_put(id,what);\n{{/if}}\n  yield csp.put(chan, JSON.parse(JSON.stringify(what)));\n}\n"},{"template":"atomics","file":"semantics/javascript/templates/csp/atomics.js","process":"implementations","template-file":"{{#if implementation.implementation}}\nvar {{implementation.name}}_{{node.id}} = function(){\n  var storage = {};\n  return function*(InQueues, OutQueues, name, meta){\n{{~#unless implementation.input}}\n  while(true){\n{{~/unless}}\n    var output = {};\n{{~#each symbol.connectors}}{{#if_eq type \"Output\"}}\n    output['{{name}}'] = { meta: {} };\n{{~/if_eq}}{{#if_eq type \"Generator\"}}\n    output['{{name}}'] = { meta: {} };\n{{~/if_eq}}{{/each}}\n    var input = {};\n{{~#unless implementation.explicit-input}}\n{{~#each symbol.connectors}}{{#if_eq type \"Input\"}}\n    {{input-data name}};\n    {{~#if ../../debug}}\n    debug_take_pre(name + \":{{name}}\");\n    {{~/if}}\n{{~/if_eq}}{{/each}}{{~#each symbol.connectors}}{{#if_eq type \"Input\"}}\n    {{~#if ../../debug}}\n    debug_take_post(name + \":{{name}}\");\n    {{~/if}}\n{{~/if_eq}}{{/each}}{{/unless}}\n    {{implementation.implementation}}\n{{~#unless implementation.explicit-callback}}\n    {{#each symbol.connectors}}{{#if_eq type \"Output\"}}\n    {{output-data name}}\n{{/if_eq}}{{#if_eq type \"Generator\"}}\n    {{output-data name}}\n{{~/if_eq}}{{/each}}\n{{~/unless}}\n  }\n{{~#unless implementation.input}}\n}\n{{~/unless}}\n}();\n{{~/if}}\n"},{"template":"graph","file":"semantics/javascript/templates/csp/graph.js","process":"graph","template-file":"function Connection_Graph(){\n  var qOutput = {\n{{~#each connections}}\n    \"{{from.generic}}__{{from.mangle}}:{{from.connector}}\" : csp.chan(),\n{{~/each}}\n  };\n  var qInput = {\n{{~#each connections}}\n    \"{{to.generic}}__{{to.mangle}}:{{to.connector}}\" : qOutput[\"{{from.generic}}__{{from.mangle}}:{{from.connector}}\"],\n{{~/each}}\n  };\n\n{{#each nodes}}\n  Node_{{id}}(qInput, qOutput, {{node-meta-to-string meta}});\n{{~/each}}\n\n{{#if debug}}\n{{~#each connections}}\n  outInMap[\"{{to.generic}}__{{to.mangle}}:{{to.connector}}\"] = \"{{from.generic}}__{{from.mangle}}:{{from.connector}}\";\n{{~/each}}\n{{~/if}}\n}\n"},{"template":"nodes","file":"semantics/javascript/templates/csp/nodes.js","process":"nodes","template-file":"function Node_{{node.id}} (InQueues, OutQueues, meta){\n{{#if implementation.atomic}}\n  var name = \"{{node.id}}__{{node.mangle}}\";\n  csp.go({{implementation.name}}_{{node.id}},[InQueues, OutQueues, name, meta]);\n{{/if}}\n}\n"},{"template":"starter","file":"semantics/javascript/templates/csp/starter.js","process":"once","template-file":"Connection_Graph();\n"}],"postprocessing":[{"name":"multiple-outputs","process":"outputs","procedure-file":"semantics/javascript/processing/multiple-outputs.ls","procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  CSP Multiple Outputs\n###  CSP can only have one distinct output for every node\n###  this method creates nodes that clone each stream if a Connector\n###  is connector to more than one other node\n\n# creates a uniqe name for the output connector of a node\nc-name = (c) ->\n  cname = c.from.generic + \"__\" + c.from.mangle + \"__\" + c.from.connector\n  if c.type == \"Inverse\"\n    cname = cname + \"_INV\"\n  return cname\n\n# creates a unique new name for the clone node\nclone-name = (name) ->\n  \"Clone__\" + name\n\nnode-connectors-with-multiple-outputs = (graph) ->\n  # group nodes by their output connector\n  node-outs = (graph.connections |> group-by (c) -> c-name c)\n  # filter all with only one output those are okay for csp\n  node-outs |> Obj.filter -> it.length > 1\n\nreturn (graph) ->\n\n  mult-nodes = node-connectors-with-multiple-outputs graph\n\n  # create clone nodes\n  new-nodes = (values mult-nodes) |> map ->\n    {\n      name: \"Clone\" + it.length  # length encoding is resolved in later postprocessing steps\n      id: clone-name it.0.from.generic\n      parent-group: it.0.parent-group\n    }\n\n  old-connections = graph.connections |> filter (c) ->\n    cname = c-name c\n    not (cname of mult-nodes)\n\n  new-connections = (values mult-nodes) |> map (c-list) ->\n    c-stream = 0\n    cn = clone-name c-list.0.from.generic\n    connections = c-list |> map (c) ->\n      c-stream := c-stream + 1\n      {\n        from: {\n          generic: cn\n          connector: \"Stream#c-stream\"\n        }\n        to: c.to\n        type: \"Normal\"\n        parent-group: c.parent-group\n      }\n    union connections, [{\n      from: c-list.0.from\n      to: {\n        generic: cn\n        connector: \"Stream\"\n      }\n      type: \"Normal\"\n      parent-group: c-list.0.parent-group\n    }]\n\n\n  new-graph = {\n    nodes: union graph.nodes, new-nodes\n    connections: union old-connections, (flatten new-connections)\n  }\n  return new-graph\n"},{"name":"multi-clone","process":"outputs","procedure-file":"semantics/javascript/processing/multi-clone.ls","dependencies":["multiple-outputs"],"procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  CSP Multi Clone\n###  To emulate arbitrary output connections streams are cloned\n###  An arbitrary number of outgoing connectors is required but not\n###  possible so we have to emulate this behaviour by manipulating the graph.\n\nreturn (graph) ->\n  graph.nodes = graph.nodes |> map (n) ->\n    if (take 5, n.name) == \"Clone\"\n      if (drop 5, n.name) == \"2\"\n        {\n          name: \"Clone\",\n          id: n.id\n          parent-group: n.parent-group\n        }\n      else\n        throw new Error \"Clone with more than 2 outputs not supported yet\"\n    else\n      n\n\n  graph\n"},{"name":"loops","process":"outputs","procedure-file":"semantics/javascript/processing/loops.ls","procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  Loops\n###  This post processing module finds loops and adds groups that\n###  stop looping after the last element.\n\n\n# unique representation of an node\nid = (v) ->\n  v.generic\n\n# gets the outgoing edges of an vertex\nout-edges = (graph, v) ->\n  graph.connections |> filter -> (id it.from) == v\n\n# find loops in a graph and returns an array of every loop\nloops = (graph) ->\n  # use DFS to find loops\n  pred = {}\n  finished = {}\n  loop-list = []\n\n  dfs-recursive = (u, v) ->\n    cnid = (id v)  + \":\" + v.connector\n    pred[cnid] = [{generic: (id u), connector: u.connector, to: (id v), to-conn: v.connector}]\n\n    (out-edges graph, id v) |> map (c) ->\n      ccnid = (id c.to) + \":\" + c.to.connector\n      if not (ccnid of pred)\n        dfs-recursive c.from, c.to\n      else if not (ccnid of finished)\n        pred[ccnid].push generic: (id v), connector: c.from.connector, to: (id c.to), to-conn: c.to.connector\n        loop-list.push { generic: (id v), connector: v.connector, from: u.generic, from-conn: u.connector }\n\n    finished[cnid] = true\n\n  graph.nodes |> map (v) ->\n    (out-edges graph, v.id) |> map (c) ->\n      ccnid = (id c.to) + \":\" + c.to.connector\n      if (not (ccnid of pred))\n        dfs-recursive c.from , c.to\n\n  double-connection = (values pred) |> filter (c) ->\n    c.length == 2\n\n  generic-id = (dc) ->\n    conn_id = join \"_\", (words dc.0.to-conn)\n    dc.0.to + \"__\" + conn_id + \"CSPLoopControl\"\n\n  new-nodes = (double-connection) |> map (dc) ->\n    {\n      name: \"CSPLoopControl\",\n      id: generic-id dc,\n    }\n\n  connections = graph.connections |> filter (c) ->\n    not (double-connection |> any (dc) ->\n      dc.0.to == c.to.generic and dc.0.to-conn == c.to.connector)\n\n  new-connections = double-connection |> map (dc) ->\n    [\n      {\n        from: { generic: (generic-id dc), connector: \"OutStream\" }\n        to: {  generic: dc.0.to,  connector: dc.0.to-conn }\n        type: \"Normal\"\n      }\n      {\n        from: { generic: dc.0.generic, connector: dc.0.connector }\n        to: {  generic: (generic-id dc), connector: \"Initial\" }\n        type: \"Normal\"\n      }\n      {\n        from: { generic: dc.1.generic, connector: dc.1.connector }\n        to: { generic: (generic-id dc), connector: \"Stream\" }\n        type: \"Normal\"\n      }\n    ]\n\n  {\n    nodes: union graph.nodes, new-nodes\n    connections: union connections, (flatten new-connections)\n  }\n\nreturn (graph) ->\n  loops graph\n"}]},{"name":"js-csp-worker","language":"javascript","target-plattform":"browser","description":"uses CSP to construct a javascript web-worker program with channel communication between groups","templates":[{"template":"program","file":"semantics/javascript/templates/csp/program-worker.js","process":"once","template-file":"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n//##content#begin\n\\{{header}}\n\nvar registerInput;\nvar sendOutput;\n\\{{atomics}}\n\\{{nodes}}\n\\{{graph}}\n\nvar __input__;\n// make scope bound to avoid possible side effects\n(function(){\n  // map id -> callback\n  var inputs = {};\n  __input__ = function(id, content){\n    if(!(id in inputs)){\n      postMessage({type:\"error\", content:\"input \\\"\"+ id +\"\\\" not registered\"});\n      return;\n    }\n    inputs[id](content);\n  }\n  registerInput = function(id, callback){\n    // register callback\n    if(id in inputs){\n      postMessage({type:\"error\", content:\"input \\\"\"+ id +\"\\\" registered twice\"});\n      return;\n    }\n    postMessage({type:\"register\",what:\"input\",node:id});\n    inputs[id] = callback;\n  }\n  sendOutput = function(id, content){\n    postMessage({type:\"output\", id:id, content:content});\n  }\n}());\n\nself.onmessage=function(event){\n  var msg = event.data;\n  if(msg == \"start\"){\n    \\{{starter}};\n    postMessage(\"ready\");\n    return;\n  }\n  else if(\"type\" in msg && msg.type == \"query\"){\n    {{~#if debug}}\n    if(msg.query == \"non-empty-channels\"){\n      postMessage({type:\"query-result\", query:\"non-empty-channels\", data: notTaken});\n    }\n    {{/if}}\n    {{~#unless debug}}\n    console.log(\"All query features are only enabled in debug mode\");\n    {{/unless}}\n  }\n  else {\n    __input__(msg.id, msg.content);\n  }\n}\n//##content#end\n\\{{requires}}\n"},{"template":"requires","file":"semantics/javascript/templates/csp/requires.js","process":"once","template-file":"},{\"js-csp\":3,\"object-merge\":13}],2:[function(require,module,exports){\n\"use strict\";\n\nvar buffers = require(\"./impl/buffers\");\nvar channels = require(\"./impl/channels\");\nvar select = require(\"./impl/select\");\nvar process = require(\"./impl/process\");\nvar timers = require(\"./impl/timers\");\n\nfunction spawn(gen, returnChannel) {\n  if (returnChannel) {\n    var ch = channels.chan(buffers.fixed(1));\n    (new process.Process(gen, function(value) {\n      process.put_then_callback(ch, value, function(ok) {\n        ch.close();\n      });\n    })).run();\n    return ch;\n  } else {\n    (new process.Process(gen)).run();\n    return null;\n  }\n};\n\nfunction go(f, args, returnChannel) {\n  var gen = f.apply(null, args);\n  return spawn(gen, returnChannel);\n};\n\nfunction chan(bufferOrNumber) {\n  var buf;\n  if (bufferOrNumber === 0) {\n    bufferOrNumber = null;\n  }\n  if (typeof bufferOrNumber === \"number\") {\n    buf = buffers.fixed(bufferOrNumber);\n  } else {\n    buf = bufferOrNumber;\n  }\n  return channels.chan(buf);\n};\n\n\nmodule.exports = {\n  buffers: {\n    fixed: buffers.fixed,\n    dropping: buffers.dropping,\n    sliding: buffers.sliding\n  },\n\n  spawn: spawn,\n  go: go,\n  chan: chan,\n  DEFAULT: select.DEFAULT,\n  CLOSED: channels.CLOSED,\n\n  put: process.put,\n  take: process.take,\n  sleep: process.sleep,\n  alts: process.alts,\n  putAsync: process.put_then_callback,\n  takeAsync: process.take_then_callback,\n\n  timeout: timers.timeout\n};\n\n},{\"./impl/buffers\":5,\"./impl/channels\":6,\"./impl/process\":8,\"./impl/select\":9,\"./impl/timers\":10}],3:[function(require,module,exports){\n\"use strict\";\n\nvar csp = require(\"./csp.core\");\nvar operations = require(\"./csp.operations\");\n\ncsp.operations = operations;\n\nmodule.exports = csp;\n\n},{\"./csp.core\":2,\"./csp.operations\":4}],4:[function(require,module,exports){\n\"use strict\";\n\nvar Box = require(\"./impl/channels\").Box;\n\nvar csp = require(\"./csp.core\"),\n    go = csp.go,\n    take = csp.take,\n    put = csp.put,\n    takeAsync = csp.takeAsync,\n    putAsync = csp.putAsync,\n    alts = csp.alts,\n    chan = csp.chan,\n    CLOSED = csp.CLOSED;\n\n\nfunction noOp(v) {\n}\n\nfunction mapFrom(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(value, handler);\n    },\n    _take: function(handler) {\n      var result = ch._take({\n        is_active: function() {\n          return handler.is_active();\n        },\n        commit: function() {\n          var take_cb = handler.commit();\n          return function(value) {\n            return take_cb(value === CLOSED ? CLOSED : f(value));\n          };\n        }\n      });\n      if (result) {\n        var value = result.value;\n        return new Box(value === CLOSED ? CLOSED : f(value));\n      } else {\n        return null;\n      }\n    }\n  };\n}\n\nfunction mapInto(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(f(value), handler);\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction filterFrom(p, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        out.close();\n        break;\n      }\n      if (p(value)) {\n        yield put(out, value);\n      }\n    }\n  });\n  return out;\n}\n\nfunction filterInto(p, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      if (p(value)) {\n        return ch._put(value, handler);\n      } else {\n        return new Box(!ch.is_closed());\n      }\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction removeFrom(p, ch) {\n  return filterFrom(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction removeInto(p, ch) {\n  return filterInto(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction* mapcat(f, src, dst) {\n  while (true) {\n    var value = yield take(src);\n    if (value === CLOSED) {\n      dst.close();\n      break;\n    } else {\n      var seq = f(value);\n      var length = seq.length;\n      for (var i = 0; i < length; i++) {\n        yield put(dst, seq[i]);\n      }\n      if (dst.is_closed()) {\n        break;\n      }\n    }\n  }\n}\n\nfunction mapcatFrom(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(mapcat, [f, ch, out]);\n  return out;\n}\n\nfunction mapcatInto(f, ch, bufferOrN) {\n  var src = chan(bufferOrN);\n  go(mapcat, [f, src, ch]);\n  return src;\n}\n\nfunction pipe(src, dst, keepOpen) {\n  go(function*() {\n    while (true) {\n      var value = yield take(src);\n      if (value === CLOSED) {\n        if (!keepOpen) {\n          dst.close();\n        }\n        break;\n      }\n      if (!(yield put(dst, value))) {\n        break;\n      }\n    }\n  });\n  return dst;\n}\n\nfunction split(p, ch, trueBufferOrN, falseBufferOrN) {\n  var tch = chan(trueBufferOrN);\n  var fch = chan(falseBufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        tch.close();\n        fch.close();\n        break;\n      }\n      yield put(p(value) ? tch : fch, value);\n    }\n  });\n  return [tch, fch];\n}\n\nfunction reduce(f, init, ch) {\n  return go(function*() {\n    var result = init;\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        return result;\n      } else {\n        result = f(result, value);\n      }\n    }\n  }, [], true);\n}\n\nfunction onto(ch, coll, keepOpen) {\n  return go(function*() {\n    var length = coll.length;\n    // FIX: Should be a generic looping interface (for...in?)\n    for (var i = 0; i < length; i++) {\n      yield put(ch, coll[i]);\n    }\n    if (!keepOpen) {\n      ch.close();\n    }\n  });\n}\n\n// TODO: Bounded?\nfunction fromColl(coll) {\n  var ch = chan(coll.length);\n  onto(ch, coll);\n  return ch;\n}\n\nfunction map(f, chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var length = chs.length;\n  // Array holding 1 round of values\n  var values = new Array(length);\n  // TODO: Not sure why we need a size-1 buffer here\n  var dchan = chan(1);\n  // How many more items this round\n  var dcount;\n  // put callbacks for each channel\n  var dcallbacks = new Array(length);\n  for (var i = 0; i < length; i ++) {\n    dcallbacks[i] = (function(i) {\n      return function(value) {\n        values[i] = value;\n        dcount --;\n        if (dcount === 0) {\n          putAsync(dchan, values.slice(0), noOp);\n        }\n      };\n    }(i));\n  }\n  go(function*() {\n    while (true) {\n      dcount = length;\n      // We could just launch n goroutines here, but for effciency we\n      // don't\n      for (var i = 0; i < length; i ++) {\n        try {\n          takeAsync(chs[i], dcallbacks[i]);\n        } catch (e) {\n          // FIX: Hmm why catching here?\n          dcount --;\n        }\n      }\n      var values = yield take(dchan);\n      for (i = 0; i < length; i ++) {\n        if (values[i] === CLOSED) {\n          out.close();\n          return;\n        }\n      }\n      yield put(out, f.apply(null, values));\n    }\n  });\n  return out;\n}\n\nfunction merge(chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var actives = chs.slice(0);\n  go(function*() {\n    while (true) {\n      if (actives.length === 0) {\n        break;\n      }\n      var r = yield alts(actives);\n      var value = r.value;\n      if (value === CLOSED) {\n        // Remove closed channel\n        var i = actives.indexOf(r.channel);\n        actives.splice(i, 1);\n        continue;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction into(coll, ch) {\n  var result = coll.slice(0);\n  return reduce(function(result, item) {\n    result.push(item);\n    return result;\n  }, result, ch);\n}\n\nfunction takeN(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    for (var i = 0; i < n; i ++) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nvar NOTHING = {};\n\nfunction unique(ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      if (value === last) {\n        continue;\n      }\n      last = value;\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction partitionBy(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var part = [];\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        if (part.length > 0) {\n          yield put(out, part);\n        }\n        out.close();\n        break;\n      } else {\n        var newItem = f(value);\n        if (newItem === last || last === NOTHING) {\n          part.push(value);\n        } else {\n          yield put(out, part);\n          part = [value];\n        }\n        last = newItem;\n      }\n    }\n  });\n  return out;\n}\n\nfunction partition(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var part = new Array(n);\n      for (var i = 0; i < n; i++) {\n        var value = yield take(ch);\n        if (value === CLOSED) {\n          if (i > 0) {\n            yield put(out, part.slice(0, i));\n          }\n          out.close();\n          return;\n        }\n        part[i] = value;\n      }\n      yield put(out, part);\n    }\n  });\n  return out;\n}\n\n// For channel identification\nvar genId = (function() {\n  var i = 0;\n  return function() {\n    i ++;\n    return \"\" + i;\n  };\n})();\n\nvar ID_ATTR = \"__csp_channel_id\";\n\n// TODO: Do we need to check with hasOwnProperty?\nfunction len(obj) {\n  var count = 0;\n  for (var p in obj) {\n    count ++;\n  }\n  return count;\n}\n\nfunction chanId(ch) {\n  var id = ch[ID_ATTR];\n  if (id === undefined) {\n    id = ch[ID_ATTR] = genId();\n  }\n  return id;\n}\n\nvar Mult = function(ch) {\n  this.taps = {};\n  this.ch = ch;\n};\n\nvar Tap = function(channel, keepOpen) {\n  this.channel = channel;\n  this.keepOpen = keepOpen;\n};\n\nMult.prototype.muxch = function() {\n  return this.ch;\n};\n\nMult.prototype.tap = function(ch, keepOpen) {\n  var id = chanId(ch);\n  this.taps[id] = new Tap(ch, keepOpen);\n};\n\nMult.prototype.untap = function(ch) {\n  delete this.taps[chanId(ch)];\n};\n\nMult.prototype.untapAll = function() {\n  this.taps = {};\n};\n\nfunction mult(ch) {\n  var m = new Mult(ch);\n  var dchan = chan(1);\n  var dcount;\n  function makeDoneCallback(tap) {\n    return function(stillOpen) {\n      dcount --;\n      if (dcount === 0) {\n        putAsync(dchan, true, noOp);\n      }\n      if (!stillOpen) {\n        m.untap(tap.channel);\n      }\n    };\n  }\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var id, t;\n      var taps = m.taps;\n      if (value === CLOSED) {\n        for (id in taps) {\n          t = taps[id];\n          if (!t.keepOpen) {\n            t.channel.close();\n          }\n        }\n        // TODO: Is this necessary?\n        m.untapAll();\n        break;\n      }\n      dcount = len(taps);\n      // XXX: This is because putAsync can actually call back\n      // immediately. Fix that\n      var initDcount = dcount;\n      // Put value on tapping channels...\n      for (id in taps) {\n        t = taps[id];\n        putAsync(t.channel, value, makeDoneCallback(t));\n      }\n      // ... waiting for all puts to complete\n      if (initDcount > 0) {\n        yield take(dchan);\n      }\n    }\n  });\n  return m;\n}\n\nmult.tap = function tap(m, ch, keepOpen) {\n  m.tap(ch, keepOpen);\n  return ch;\n};\n\nmult.untap = function untap(m, ch) {\n  m.untap(ch);\n};\n\nmult.untapAll = function untapAll(m) {\n  m.untapAll();\n};\n\nfunction constantlyNull() {\n  return null;\n}\n\nvar Pub = function(ch, topicFn, bufferFn) {\n  this.ch = ch;\n  this.topicFn = topicFn;\n  this.bufferFn = bufferFn;\n  this.mults = {};\n};\n\nPub.prototype._ensureMult = function(topic) {\n  var m = this.mults[topic];\n  var bufferFn = this.bufferFn;\n  if (!m) {\n    m = this.mults[topic] = mult(chan(bufferFn(topic)));\n  }\n  return m;\n};\n\nPub.prototype.sub = function(topic, ch, keepOpen) {\n  var m = this._ensureMult(topic);\n  return mult.tap(m, ch, keepOpen);\n};\n\nPub.prototype.unsub = function(topic, ch) {\n  var m = this.mults[topic];\n  if (m) {\n    mult.untap(m, ch);\n  }\n};\n\nPub.prototype.unsubAll = function(topic) {\n  if (topic === undefined) {\n    this.mults = {};\n  } else {\n    delete this.mults[topic];\n  }\n};\n\nfunction pub(ch, topicFn, bufferFn) {\n  bufferFn = bufferFn || constantlyNull;\n  var p = new Pub(ch, topicFn, bufferFn);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var mults = p.mults;\n      var topic;\n      if (value === CLOSED) {\n        for (topic in mults) {\n          mults[topic].muxch().close();\n        }\n        break;\n      }\n      // TODO: Somehow ensure/document that this must return a string\n      // (otherwise use proper (hash)maps)\n      topic = topicFn(value);\n      var m = mults[topic];\n      if (m) {\n        var stillOpen = yield put(m.muxch(), value);\n        if (!stillOpen) {\n          delete mults[topic];\n        }\n      }\n    }\n  });\n  return p;\n}\n\npub.sub = function sub(p, topic, ch, keepOpen) {\n  return p.sub(topic, ch, keepOpen);\n};\n\npub.unsub = function unsub(p, topic, ch) {\n  p.unsub(topic, ch);\n};\n\npub.unsubAll = function unsubAll(p, topic) {\n  p.unsubAll(topic);\n};\n\nmodule.exports = {\n  mapFrom: mapFrom,\n  mapInto: mapInto,\n  filterFrom: filterFrom,\n  filterInto: filterInto,\n  removeFrom: removeFrom,\n  removeInto: removeInto,\n  mapcatFrom: mapcatFrom,\n  mapcatInto: mapcatInto,\n\n  pipe: pipe,\n  split: split,\n  reduce: reduce,\n  onto: onto,\n  fromColl: fromColl,\n\n  map: map,\n  merge: merge,\n  into: into,\n  take: takeN,\n  unique: unique,\n  partition: partition,\n  partitionBy: partitionBy\n};\n\n\n// Possible \"fluid\" interfaces:\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc],\n//   [into, []]\n// )\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc, _],\n//   [into, [], _]\n// )\n\n// wrap()\n//   .fromColl([1, 2, 3, 4])\n//   .mapFrom(inc)\n//   .into([])\n//   .unwrap();\n\n},{\"./csp.core\":2,\"./impl/channels\":6}],5:[function(require,module,exports){\n\"use strict\";\n\n// TODO: Consider EmptyError & FullError to avoid redundant bound\n// checks, to improve performance (may need benchmarks)\n\nfunction acopy(src, src_start, dst, dst_start, length) {\n  var count = 0;\n  while (true) {\n    if (count >= length) {\n      break;\n    }\n    dst[dst_start + count] = src[src_start + count];\n    count ++;\n  }\n}\n\nvar EMPTY = {\n  toString: function() {\n    return \"[object EMPTY]\";\n  }\n};\n\nvar RingBuffer = function(head, tail, length, array) {\n  this.length = length;\n  this.array = array;\n  this.head = head;\n  this.tail = tail;\n};\n\n// Internal method, callers must do bound check\nRingBuffer.prototype._unshift = function(item) {\n  var array = this.array;\n  var head = this.head;\n  array[head] = item;\n  this.head = (head + 1) % array.length;\n  this.length ++;\n};\n\nRingBuffer.prototype._resize = function() {\n  var array = this.array;\n  var new_length = 2 * array.length;\n  var new_array = new Array(new_length);\n  var head = this.head;\n  var tail = this.tail;\n  var length = this.length;\n  if (tail < head) {\n    acopy(array, tail, new_array, 0, length);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail > head) {\n    acopy(array, tail, new_array, 0, array.length - tail);\n    acopy(array, 0, new_array, array.length - tail, head);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail === head) {\n    this.tail = 0;\n    this.head = 0;\n    this.array = new_array;\n  }\n};\n\nRingBuffer.prototype.unbounded_unshift = function(item) {\n  if (this.length + 1 === this.array.length) {\n    this._resize();\n  }\n  this._unshift(item);\n};\n\nRingBuffer.prototype.pop = function() {\n  if (this.length === 0) {\n    return EMPTY;\n  }\n  var array = this.array;\n  var tail = this.tail;\n  var item = array[tail];\n  array[tail] = null;\n  this.tail = (tail + 1) % array.length;\n  this.length --;\n  return item;\n};\n\nRingBuffer.prototype.cleanup = function(predicate) {\n  var length = this.length;\n  for (var i = 0; i < length; i++) {\n    var item = this.pop();\n    if (predicate(item)) {\n      this._unshift(item);\n    }\n  }\n};\n\n\nvar FixedBuffer = function(buf,  n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nFixedBuffer.prototype.is_full = function() {\n  return this.buf.length == this.n;\n};\n\nFixedBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nFixedBuffer.prototype.add = function(item) {\n  if (this.is_full()) {\n    throw new Error(\"Can't add to a full buffer\");\n  }\n  this.buf._unshift(item);\n};\n\nFixedBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar DroppingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nDroppingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nDroppingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nDroppingBuffer.prototype.add = function(item) {\n  if (this.buf.length < this.n) {\n    this.buf._unshift(item);\n  }\n};\n\nDroppingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar SlidingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nSlidingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nSlidingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nSlidingBuffer.prototype.add = function(item) {\n  if (this.buf.length === this.n) {\n    this.buf.pop();\n  }\n  this.buf._unshift(item);\n};\n\nSlidingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\n\nvar ring = exports.ring = function ring_buffer(n) {\n  return new RingBuffer(0, 0, 0, new Array(n));\n};\n\nexports.fixed = function fixed_buffer(n) {\n  return new FixedBuffer(ring(n), n);\n};\n\nexports.dropping = function dropping_buffer(n) {\n  return new DroppingBuffer(ring(n), n);\n};\n\nexports.sliding = function sliding_buffer(n) {\n  return new SlidingBuffer(ring(n), n);\n};\n\nexports.EMPTY = EMPTY;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nvar buffers = require(\"./buffers\");\nvar dispatch = require(\"./dispatch\");\n\nvar MAX_DIRTY = 64;\nvar MAX_QUEUE_SIZE = 1024;\n\nvar CLOSED = null;\n\nvar Box = function(value) {\n  this.value = value;\n};\n\nvar PutBox = function(handler, value) {\n  this.handler = handler;\n  this.value = value;\n};\n\nvar Channel = function(takes, puts, buf) {\n  this.buf = buf;\n  this.takes = takes;\n  this.puts = puts;\n\n  this.dirty_takes = 0;\n  this.dirty_puts = 0;\n  this.closed = false;\n};\n\nChannel.prototype._put = function(value, handler) {\n  if (value === CLOSED) {\n    throw new Error(\"Cannot put CLOSED on a channel.\");\n  }\n\n  if (this.closed || !handler.is_active()) {\n    return new Box(!this.closed);\n  }\n\n  while (true) {\n    var taker = this.takes.pop();\n    if (taker !== buffers.EMPTY) {\n      if (taker.is_active()) {\n        var callback = taker.commit();\n        handler.commit();\n        dispatch.run(function() {\n          callback(value);\n        });\n        return new Box(true);\n      } else {\n        continue;\n      }\n    } else {\n      if (this.buf && !this.buf.is_full()) {\n        handler.commit();\n        this.buf.add(value);\n        return new Box(true);\n      } else {\n        if (this.dirty_puts > MAX_DIRTY) {\n          this.puts.cleanup(function(putter) {\n            return putter.handler.is_active();\n          });\n          this.dirty_puts = 0;\n        } else {\n          this.dirty_puts ++;\n        }\n        if (this.puts.length >= MAX_QUEUE_SIZE) {\n          throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending puts are allowed on a single channel.\");\n        }\n        this.puts.unbounded_unshift(new PutBox(handler, value));\n      }\n    }\n    break;\n  }\n\n  return null;\n};\n\nChannel.prototype._take = function(handler) {\n  if (!handler.is_active()) {\n    return null;\n  }\n\n  var putter, put_handler, callback;\n\n  if (this.buf && this.buf.count() > 0) {\n    handler.commit();\n    var value = this.buf.remove();\n    // We need to check pending puts here, other wise they won't\n    // be able to proceed until their number reaches MAX_DIRTY\n    while (true) {\n      putter = this.puts.pop();\n      if (putter !== buffers.EMPTY) {\n        put_handler = putter.handler;\n        if (put_handler.is_active()) {\n          callback = put_handler.commit();\n          dispatch.run(function() {\n            callback(true);\n          });\n          this.buf.add(putter.value);\n          break;\n        } else {\n          continue;\n        }\n      }\n      break;\n    }\n    return new Box(value);\n  }\n\n  while (true) {\n    putter = this.puts.pop();\n    if (putter !== buffers.EMPTY) {\n      put_handler = putter.handler;\n      if (put_handler.is_active()) {\n        handler.commit();\n        callback = put_handler.commit();\n        dispatch.run(function() {\n          callback(true);\n        });\n        return new Box(putter.value);\n      } else {\n        continue;\n      }\n    } else {\n      if (this.closed) {\n        handler.commit();\n        return new Box(CLOSED);\n      } else {\n        if (this.dirty_takes > MAX_DIRTY) {\n          this.takes.cleanup(function(handler) {\n            return handler.is_active();\n          });\n          this.dirty_takes = 0;\n        } else {\n          this.dirty_takes ++;\n        }\n        if (this.takes.length >= MAX_QUEUE_SIZE) {\n          throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending takes are allowed on a single channel.\");\n        }\n        this.takes.unbounded_unshift(handler);\n      }\n    }\n    break;\n  }\n\n  return null;\n};\n\nChannel.prototype.close = function() {\n  if (this.closed) {\n    return;\n  }\n  this.closed = true;\n  while (true) {\n    var taker = this.takes.pop();\n    if (taker === buffers.EMPTY) {\n      break;\n    }\n    if (taker.is_active()) {\n      var callback = taker.commit();\n      dispatch.run(function() {\n        callback(CLOSED);\n      });\n    }\n  }\n  // TODO: Tests\n  while (true) {\n    var putter = this.puts.pop();\n    if (putter === buffers.EMPTY) {\n      break;\n    }\n    if (putter.handler.is_active()) {\n      var put_callback = putter.handler.commit();\n      dispatch.run(function() {\n        put_callback(false);\n      });\n    }\n  }\n};\n\n\nChannel.prototype.is_closed = function() {\n  return this.closed;\n};\n\n\nexports.chan = function(buf) {\n  return new Channel(buffers.ring(32), buffers.ring(32), buf);\n};\n\nexports.Box = Box;\n\nexports.CLOSED = CLOSED;\n\n},{\"./buffers\":5,\"./dispatch\":7}],7:[function(require,module,exports){\n\"use strict\";\n\n// TODO: Use process.nextTick if it's available since it's more\n// efficient\n// http://howtonode.org/understanding-process-next-tick\n// Maybe we don't even need to queue ourselves in that case?\n\n// XXX: But http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/\n// Looks like it will blow up the stack (or is that just about\n// pre-empting IO (but that's already bad enough IMO)?)\n\n// Looks like\n// http://nodejs.org/api/process.html#process_process_nexttick_callback\n// is the equivalent of our TASK_BATCH_SIZE\n\nvar buffers = require(\"./buffers\");\n\nvar TASK_BATCH_SIZE = 1024;\n\nvar tasks = buffers.ring(32);\nvar running = false;\nvar queued = false;\n\nvar queue_dispatcher;\n\nfunction process_messages() {\n  running = true;\n  queued = false;\n  var count = 0;\n  while (true) {\n    var task = tasks.pop();\n    if (task === buffers.EMPTY) {\n      break;\n    }\n    // TODO: Don't we need a try/finally here?\n    task();\n    if (count >= TASK_BATCH_SIZE) {\n      break;\n    }\n    count ++;\n  }\n  running = false;\n  if (tasks.length > 0) {\n    queue_dispatcher();\n  }\n}\n\nif (typeof MessageChannel !== \"undefined\") {\n  var message_channel = new MessageChannel();\n  message_channel.port1.onmessage = function(_) {\n    process_messages();\n  };\n  queue_dispatcher = function()  {\n    if (!(queued && running)) {\n      queued = true;\n      message_channel.port2.postMessage(0);\n    }\n  };\n} else if (typeof setImmediate !== \"undefined\") {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setImmediate(process_messages);\n    }\n  };\n} else {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setTimeout(process_messages, 0);\n    }\n  };\n}\n\nexports.run = function (f) {\n  tasks.unbounded_unshift(f);\n  queue_dispatcher();\n};\n\nexports.queue_delay = function(f, delay) {\n  setTimeout(f, delay);\n};\n\n},{\"./buffers\":5}],8:[function(require,module,exports){\n\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar select = require(\"./select\");\n\nvar FnHandler = function(f) {\n  this.f = f;\n};\n\nFnHandler.prototype.is_active = function() {\n  return true;\n};\n\nFnHandler.prototype.commit = function() {\n  return this.f;\n};\n\nfunction put_then_callback(channel, value, callback) {\n  var result = channel._put(value, new FnHandler(callback));\n  if (result) {\n    callback(result.value);\n  }\n}\n\nfunction take_then_callback(channel, callback) {\n  var result = channel._take(new FnHandler(callback));\n  if (result) {\n    callback(result.value);\n  }\n}\n\nvar Process = function(gen, onFinish) {\n  this.gen = gen;\n  this.finished = false;\n  this.onFinish = onFinish;\n};\n\nvar Instruction = function(op, data) {\n  this.op = op;\n  this.data = data;\n};\n\nvar TAKE = \"take\";\nvar PUT = \"put\";\nvar SLEEP = \"sleep\";\nvar ALTS = \"alts\";\n\n// TODO FIX XXX: This is a (probably) temporary hack to avoid blowing\n// up the stack, but it means double queueing when the value is not\n// immediately available\nProcess.prototype._continue = function(response) {\n  var self = this;\n  dispatch.run(function() {\n    self.run(response);\n  });\n};\n\nProcess.prototype._done = function(value) {\n  if (!this.finished) {\n    this.finished = true;\n    var onFinish = this.onFinish;\n    if (typeof onFinish === \"function\") {\n      dispatch.run(function() {\n        onFinish(value);\n      });\n    }\n  }\n};\n\nProcess.prototype.run = function(response) {\n  if (this.finished) {\n    return;\n  }\n\n  // TODO: Shouldn't we (optionally) stop error propagation here (and\n  // signal the error through a channel or something)? Otherwise the\n  // uncaught exception will crash some runtimes (e.g. Node)\n  var iter = this.gen.next(response);\n  if (iter.done) {\n    this._done(iter.value);\n    return;\n  }\n\n  var ins = iter.value;\n\n  if (ins instanceof Instruction) {\n    var self = this;\n    switch (ins.op) {\n    case PUT:\n      var data = ins.data;\n      put_then_callback(data.channel, data.value, function(ok) {\n        self._continue(ok);\n      });\n      break;\n\n    case TAKE:\n      var channel = ins.data;\n      take_then_callback(channel, function(value) {\n        self._continue(value);\n      });\n      break;\n\n    case SLEEP:\n      var msecs = ins.data;\n      dispatch.queue_delay(function() {\n        self.run(null);\n      }, msecs);\n      break;\n\n    case ALTS:\n      select.do_alts(ins.data.operations, function(result) {\n        self._continue(result);\n      }, ins.data.options);\n      break;\n    }\n  } else {\n    this._continue(ins);\n  }\n};\n\nfunction take(channel) {\n  return new Instruction(TAKE, channel);\n}\n\nfunction put(channel, value) {\n  return new Instruction(PUT, {\n    channel: channel,\n    value: value\n  });\n}\n\nfunction sleep(msecs) {\n  return new Instruction(SLEEP, msecs);\n}\n\nfunction alts(operations, options) {\n  return new Instruction(ALTS, {\n    operations: operations,\n    options: options\n  });\n}\n\nexports.put_then_callback = put_then_callback;\nexports.take_then_callback = take_then_callback;\nexports.put = put;\nexports.take = take;\nexports.sleep = sleep;\nexports.alts = alts;\n\nexports.Process = Process;\n\n},{\"./dispatch\":7,\"./select\":9}],9:[function(require,module,exports){\n\"use strict\";\n\nvar Box = require(\"./channels\").Box;\n\nvar AltHandler = function(flag, f) {\n  this.f = f;\n  this.flag = flag;\n};\n\nAltHandler.prototype.is_active = function() {\n  return this.flag.value;\n};\n\nAltHandler.prototype.commit = function() {\n  this.flag.value = false;\n  return this.f;\n};\n\nvar AltResult = function(value, channel) {\n  this.value = value;\n  this.channel = channel;\n};\n\nfunction rand_int(n) {\n  return Math.floor(Math.random() * (n + 1));\n}\n\nfunction random_array(n) {\n  var a = new Array(n);\n  var i;\n  for (i = 0; i < n; i++) {\n    a[i] = 0;\n  }\n  for (i = 1; i < n; i++) {\n    var j = rand_int(i);\n    a[i] = a[j];\n    a[j] = i;\n  }\n  return a;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar DEFAULT = {\n  toString: function() {\n    return \"[object DEFAULT]\";\n  }\n};\n\n// TODO: Accept a priority function or something\nexports.do_alts = function(operations, callback, options) {\n  var length = operations.length;\n  // XXX Hmm\n  if (length === 0) {\n    throw new Error(\"Empty alt list\");\n  }\n\n  var priority = (options && options.priority) ? true : false;\n  if (!priority) {\n    var indexes = random_array(length);\n  }\n\n  var flag = new Box(true);\n\n  for (var i = 0; i < length; i++) {\n    var operation = operations[priority ? i : indexes[i]];\n    var port, result;\n    // XXX Hmm\n    if (operation instanceof Array) {\n      var value = operation[1];\n      port = operation[0];\n      result = port._put(value, (function(port) {\n        return new AltHandler(flag, function(ok) {\n          callback(new AltResult(ok, port));\n        });\n      })(port));\n    } else {\n      port = operation;\n      result = port._take((function(port) {\n        return new AltHandler(flag, function(value) {\n          callback(new AltResult(value, port));\n        });\n      })(port));\n    }\n    // XXX Hmm\n    if (result instanceof Box) {\n      callback(new AltResult(result.value, port));\n      break;\n    }\n  }\n\n  if (!(result instanceof Box)\n      && options\n      && hasOwnProperty.call(options, \"default\")) {\n    if (flag.value) {\n      flag.value = false;\n      callback(new AltResult(options[\"default\"], DEFAULT));\n    }\n  }\n};\n\nexports.DEFAULT = DEFAULT;\n\n},{\"./channels\":6}],10:[function(require,module,exports){\n\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar channels = require(\"./channels\");\n\nexports.timeout = function timeout_channel(msecs) {\n  var chan = channels.chan();\n  dispatch.queue_delay(function() {\n    chan.close();\n  }, msecs);\n  return chan;\n};\n\n},{\"./channels\":6,\"./dispatch\":7}],11:[function(require,module,exports){\n/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\r\n/*jslint\r\n    evil: true,\r\n    node: true\r\n*/\r\n'use strict';\r\n/**\r\n * Clones non native JavaScript functions, or references native functions.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {Function} func The function to clone.\r\n * @returns {Function} Returns a clone of the non native function, or a\r\n *  reference to the native function.\r\n */\r\nfunction cloneFunction(func) {\r\n    var out, str;\r\n    try {\r\n        str = func.toString();\r\n        if (/\\[native code\\]/.test(str)) {\r\n            out = func;\r\n        } else {\r\n            out = eval('(function(){return ' + str + '}());');\r\n        }\r\n    } catch (e) {\r\n        throw new Error(e.message + '\\r\\n\\r\\n' + str);\r\n    }\r\n    return out;\r\n}\r\nmodule.exports = cloneFunction;\n},{}],12:[function(require,module,exports){\n/**\r\n * Executes a function on each of an objects own enumerable properties. The\r\n *  callback function will receive three arguments: the value of the current\r\n *  property, the name of the property, and the object being processed. This is\r\n *  roughly equivalent to the signature for callbacks to\r\n *  Array.prototype.forEach.\r\n * @param {Object} obj The object to act on.\r\n * @param {Function} callback The function to execute.\r\n * @returns {Object} Returns the given object.\r\n */\r\nfunction objectForeach(obj, callback) {\r\n    \"use strict\";\r\n    Object.keys(obj).forEach(function (prop) {\r\n        callback(obj[prop], prop, obj);\r\n    });\r\n    return obj;\r\n};\r\nmodule.exports = objectForeach;\n},{}],13:[function(require,module,exports){\n/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\r\n/*jslint\r\n    white: true,\r\n    vars: true,\r\n    node: true\r\n*/\r\nfunction ObjectMergeOptions(opts) {\r\n    'use strict';\r\n    opts = opts || {};\r\n    this.depth = opts.depth || false;\r\n    // circular ref check is true unless explicitly set to false\r\n    // ignore the jslint warning here, it's pointless.\r\n    this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\r\n}\r\n/*jslint unparam:true*/\r\n/**\r\n * Creates a new options object suitable for use with objectMerge.\r\n * @memberOf objectMerge\r\n * @param {Object} [opts] An object specifying the options.\r\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\r\n *  during merging. If this is set to false then there will be no depth limit.\r\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\r\n *  errors on circular references.\r\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\r\n *  to be used with objectMerge.\r\n * @example\r\n *  var opts = objectMerge.createOptions({\r\n *      depth : 2,\r\n *      throwOnCircularRef : false\r\n *  });\r\n *  var obj1 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : {}\r\n *          }\r\n *      }\r\n *  };\r\n *  var obj2 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : 'will not be in output'\r\n *          },\r\n *          a22 : {}\r\n *      }\r\n *  };\r\n *  objectMerge(opts, obj1, obj2);\r\n */\r\nfunction createOptions(opts) {\r\n    'use strict';\r\n    var argz = Array.prototype.slice.call(arguments, 0);\r\n    argz.unshift(null);\r\n    var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\r\n    return new F();\r\n}\r\n/*jslint unparam:false*/\r\n/**\r\n * Merges JavaScript objects recursively without altering the objects merged.\r\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {ObjectMergeOptions} [opts] An options object created by\r\n *  objectMerge.createOptions. Options must be specified as the first argument\r\n *  and must be an object created with createOptions or else the object will\r\n *  not be recognized as an options object and will be merged instead.\r\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\r\n *  argument given will be treated as an object to merge. Each object\r\n *  overwrites the previous objects descendant properties if the property name\r\n *  matches. If objects properties are objects they will be merged recursively\r\n *  as well.\r\n * @returns {Object} Returns a single merged object composed from clones of the\r\n *  input objects.\r\n * @example\r\n *  var objectMerge = require('object-merge');\r\n *  var x = {\r\n *      a : 'a',\r\n *      b : 'b',\r\n *      c : {\r\n *          d : 'd',\r\n *          e : 'e',\r\n *          f : {\r\n *              g : 'g'\r\n *          }\r\n *      }\r\n *  };\r\n *  var y = {\r\n *      a : '`a',\r\n *      b : '`b',\r\n *      c : {\r\n *          d : '`d'\r\n *      }\r\n *  };\r\n *  var z = {\r\n *      a : {\r\n *          b : '``b'\r\n *      },\r\n *      fun : function foo () {\r\n *          return 'foo';\r\n *      },\r\n *      aps : Array.prototype.slice\r\n *  };\r\n *  var out = objectMerge(x, y, z);\r\n *  // out.a will be {\r\n *  //         b : '``b'\r\n *  //     }\r\n *  // out.b will be '`b'\r\n *  // out.c will be {\r\n *  //         d : '`d',\r\n *  //         e : 'e',\r\n *  //         f : {\r\n *  //             g : 'g'\r\n *  //         }\r\n *  //     }\r\n *  // out.fun will be a clone of z.fun\r\n *  // out.aps will be equal to z.aps\r\n */\r\nfunction objectMerge(shadows) {\r\n    'use strict';\r\n    var objectForeach = require('object-foreach');\r\n    var cloneFunction = require('clone-function');\r\n    // this is the queue of visited objects / properties.\r\n    var visited = [];\r\n    // various merge options\r\n    var options = {};\r\n    // gets the sequential trailing objects from array.\r\n    function getShadowObjects(shadows) {\r\n        var out = shadows.reduce(function (collector, shadow) {\r\n                if (shadow instanceof Object) {\r\n                    collector.push(shadow);\r\n                } else {\r\n                    collector = [];\r\n                }\r\n                return collector;\r\n            }, []);\r\n        return out;\r\n    }\r\n    // gets either a new object of the proper type or the last primitive value\r\n    function getOutputObject(shadows) {\r\n        var out;\r\n        var lastShadow = shadows[shadows.length - 1];\r\n        if (lastShadow instanceof Array) {\r\n            out = [];\r\n        } else if (lastShadow instanceof Function) {\r\n            try {\r\n                out = cloneFunction(lastShadow);\r\n            } catch (e) {\r\n                throw new Error(e.message);\r\n            }\r\n        } else if (lastShadow instanceof Object) {\r\n            out = {};\r\n        } else {\r\n            // lastShadow is a primitive value;\r\n            out = lastShadow;\r\n        }\r\n        return out;\r\n    }\r\n    // checks for circular references\r\n    function circularReferenceCheck(shadows) {\r\n        // if any of the current objects to process exist in the queue\r\n        // then throw an error.\r\n        shadows.forEach(function (item) {\r\n            if (item instanceof Object && visited.indexOf(item) > -1) {\r\n                throw new Error('Circular reference error');\r\n            }\r\n        });\r\n        // if none of the current objects were in the queue\r\n        // then add references to the queue.\r\n        visited = visited.concat(shadows);\r\n    }\r\n    function objectMergeRecursor(shadows, currentDepth) {\r\n        if (options.depth !== false) {\r\n            currentDepth = currentDepth ? currentDepth + 1 : 1;\r\n        } else {\r\n            currentDepth = 0;\r\n        }\r\n        if (options.throwOnCircularRef === true) {\r\n            circularReferenceCheck(shadows);\r\n        }\r\n        var out = getOutputObject(shadows);\r\n        /*jslint unparam: true */\r\n        function shadowHandler(val, prop, shadow) {\r\n            if (out[prop]) {\r\n                out[prop] = objectMergeRecursor([\r\n                    out[prop],\r\n                    shadow[prop]\r\n                ], currentDepth);\r\n            } else {\r\n                out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\r\n            }\r\n        }\r\n        /*jslint unparam:false */\r\n        function shadowMerger(shadow) {\r\n            objectForeach(shadow, shadowHandler);\r\n        }\r\n        // short circuits case where output would be a primitive value\r\n        // anyway.\r\n        if (out instanceof Object && currentDepth <= options.depth) {\r\n            // only merges trailing objects since primitives would wipe out\r\n            // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\r\n            // would result in {b:'b'} so the first two arguments\r\n            // can be ignored completely.\r\n            var relevantShadows = getShadowObjects(shadows);\r\n            relevantShadows.forEach(shadowMerger);\r\n        }\r\n        return out;\r\n    }\r\n    // determines whether an options object was passed in and\r\n    // uses it if present\r\n    // ignore the jslint warning here too.\r\n    if (arguments[0] instanceof ObjectMergeOptions) {\r\n        options = arguments[0];\r\n        shadows = Array.prototype.slice.call(arguments, 1);\r\n    } else {\r\n        options = createOptions();\r\n        shadows = Array.prototype.slice.call(arguments, 0);\r\n    }\r\n    return objectMergeRecursor(shadows);\r\n}\r\nobjectMerge.createOptions = createOptions;\r\nmodule.exports = objectMerge;\n},{\"clone-function\":11,\"object-foreach\":12}]},{},[1]);\n"},{"template":"header","file":"semantics/javascript/templates/csp/header.js","process":"once","template-file":"var csp = require(\"js-csp\");\nvar merge = require(\"object-merge\");\n\nfunction* id(input, out){\n  while(true)\n  {\n    var taken = yield csp.take(input);\n    yield csp.put(out, taken);\n  }\n}\n\n{{~#if debug}}\n// map id -> array of things not taken\nvar notTaken = {};\nvar outInMap = {};\nfunction debug_put(id, what){\n  if(id in notTaken){\n    notTaken[id].push(what);\n  } else {\n    notTaken[id] = [what];\n  }\n}\n\nfunction debug_take_pre(id){\n  var newID = outInMap[id];\n  notTaken[newID][0].taken = true;\n}\nfunction debug_take_post(id){\n  var newID = outInMap[id];\n  notTaken[newID] = notTaken[newID].slice(1);\n}\n{{~/if}}\nfunction* outputData(id, chan, what){\n{{~#if debug}}\n  debug_put(id,what);\n{{/if}}\n  yield csp.put(chan, JSON.parse(JSON.stringify(what)));\n}\n"},{"template":"atomics","file":"semantics/javascript/templates/csp/atomics.js","process":"implementations","template-file":"{{#if implementation.implementation}}\nvar {{implementation.name}}_{{node.id}} = function(){\n  var storage = {};\n  return function*(InQueues, OutQueues, name, meta){\n{{~#unless implementation.input}}\n  while(true){\n{{~/unless}}\n    var output = {};\n{{~#each symbol.connectors}}{{#if_eq type \"Output\"}}\n    output['{{name}}'] = { meta: {} };\n{{~/if_eq}}{{#if_eq type \"Generator\"}}\n    output['{{name}}'] = { meta: {} };\n{{~/if_eq}}{{/each}}\n    var input = {};\n{{~#unless implementation.explicit-input}}\n{{~#each symbol.connectors}}{{#if_eq type \"Input\"}}\n    {{input-data name}};\n    {{~#if ../../debug}}\n    debug_take_pre(name + \":{{name}}\");\n    {{~/if}}\n{{~/if_eq}}{{/each}}{{~#each symbol.connectors}}{{#if_eq type \"Input\"}}\n    {{~#if ../../debug}}\n    debug_take_post(name + \":{{name}}\");\n    {{~/if}}\n{{~/if_eq}}{{/each}}{{/unless}}\n    {{implementation.implementation}}\n{{~#unless implementation.explicit-callback}}\n    {{#each symbol.connectors}}{{#if_eq type \"Output\"}}\n    {{output-data name}}\n{{/if_eq}}{{#if_eq type \"Generator\"}}\n    {{output-data name}}\n{{~/if_eq}}{{/each}}\n{{~/unless}}\n  }\n{{~#unless implementation.input}}\n}\n{{~/unless}}\n}();\n{{~/if}}\n"},{"template":"graph","file":"semantics/javascript/templates/csp/graph.js","process":"graph","template-file":"function Connection_Graph(){\n  var qOutput = {\n{{~#each connections}}\n    \"{{from.generic}}__{{from.mangle}}:{{from.connector}}\" : csp.chan(),\n{{~/each}}\n  };\n  var qInput = {\n{{~#each connections}}\n    \"{{to.generic}}__{{to.mangle}}:{{to.connector}}\" : qOutput[\"{{from.generic}}__{{from.mangle}}:{{from.connector}}\"],\n{{~/each}}\n  };\n\n{{#each nodes}}\n  Node_{{id}}(qInput, qOutput, {{node-meta-to-string meta}});\n{{~/each}}\n\n{{#if debug}}\n{{~#each connections}}\n  outInMap[\"{{to.generic}}__{{to.mangle}}:{{to.connector}}\"] = \"{{from.generic}}__{{from.mangle}}:{{from.connector}}\";\n{{~/each}}\n{{~/if}}\n}\n"},{"template":"nodes","file":"semantics/javascript/templates/csp/nodes.js","process":"nodes","template-file":"function Node_{{node.id}} (InQueues, OutQueues, meta){\n{{#if implementation.atomic}}\n  var name = \"{{node.id}}__{{node.mangle}}\";\n  csp.go({{implementation.name}}_{{node.id}},[InQueues, OutQueues, name, meta]);\n{{/if}}\n}\n"},{"template":"starter","file":"semantics/javascript/templates/csp/starter.js","process":"once","template-file":"Connection_Graph();\n"}],"postprocessing":[{"name":"multiple-outputs","process":"outputs","procedure-file":"semantics/javascript/processing/multiple-outputs.ls","procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  CSP Multiple Outputs\n###  CSP can only have one distinct output for every node\n###  this method creates nodes that clone each stream if a Connector\n###  is connector to more than one other node\n\n# creates a uniqe name for the output connector of a node\nc-name = (c) ->\n  cname = c.from.generic + \"__\" + c.from.mangle + \"__\" + c.from.connector\n  if c.type == \"Inverse\"\n    cname = cname + \"_INV\"\n  return cname\n\n# creates a unique new name for the clone node\nclone-name = (name) ->\n  \"Clone__\" + name\n\nnode-connectors-with-multiple-outputs = (graph) ->\n  # group nodes by their output connector\n  node-outs = (graph.connections |> group-by (c) -> c-name c)\n  # filter all with only one output those are okay for csp\n  node-outs |> Obj.filter -> it.length > 1\n\nreturn (graph) ->\n\n  mult-nodes = node-connectors-with-multiple-outputs graph\n\n  # create clone nodes\n  new-nodes = (values mult-nodes) |> map ->\n    {\n      name: \"Clone\" + it.length  # length encoding is resolved in later postprocessing steps\n      id: clone-name it.0.from.generic\n      parent-group: it.0.parent-group\n    }\n\n  old-connections = graph.connections |> filter (c) ->\n    cname = c-name c\n    not (cname of mult-nodes)\n\n  new-connections = (values mult-nodes) |> map (c-list) ->\n    c-stream = 0\n    cn = clone-name c-list.0.from.generic\n    connections = c-list |> map (c) ->\n      c-stream := c-stream + 1\n      {\n        from: {\n          generic: cn\n          connector: \"Stream#c-stream\"\n        }\n        to: c.to\n        type: \"Normal\"\n        parent-group: c.parent-group\n      }\n    union connections, [{\n      from: c-list.0.from\n      to: {\n        generic: cn\n        connector: \"Stream\"\n      }\n      type: \"Normal\"\n      parent-group: c-list.0.parent-group\n    }]\n\n\n  new-graph = {\n    nodes: union graph.nodes, new-nodes\n    connections: union old-connections, (flatten new-connections)\n  }\n  return new-graph\n"},{"name":"multi-clone","process":"outputs","procedure-file":"semantics/javascript/processing/multi-clone.ls","dependencies":["multiple-outputs"],"procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  CSP Multi Clone\n###  To emulate arbitrary output connections streams are cloned\n###  An arbitrary number of outgoing connectors is required but not\n###  possible so we have to emulate this behaviour by manipulating the graph.\n\nreturn (graph) ->\n  graph.nodes = graph.nodes |> map (n) ->\n    if (take 5, n.name) == \"Clone\"\n      if (drop 5, n.name) == \"2\"\n        {\n          name: \"Clone\",\n          id: n.id\n          parent-group: n.parent-group\n        }\n      else\n        throw new Error \"Clone with more than 2 outputs not supported yet\"\n    else\n      n\n\n  graph\n"},{"name":"loops","process":"outputs","procedure-file":"semantics/javascript/processing/loops.ls","procedure":"/* This file is part of Buggy.\n\n Buggy is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Buggy is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Buggy.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#######  Loops\n###  This post processing module finds loops and adds groups that\n###  stop looping after the last element.\n\n\n# unique representation of an node\nid = (v) ->\n  v.generic\n\n# gets the outgoing edges of an vertex\nout-edges = (graph, v) ->\n  graph.connections |> filter -> (id it.from) == v\n\n# find loops in a graph and returns an array of every loop\nloops = (graph) ->\n  # use DFS to find loops\n  pred = {}\n  finished = {}\n  loop-list = []\n\n  dfs-recursive = (u, v) ->\n    cnid = (id v)  + \":\" + v.connector\n    pred[cnid] = [{generic: (id u), connector: u.connector, to: (id v), to-conn: v.connector}]\n\n    (out-edges graph, id v) |> map (c) ->\n      ccnid = (id c.to) + \":\" + c.to.connector\n      if not (ccnid of pred)\n        dfs-recursive c.from, c.to\n      else if not (ccnid of finished)\n        pred[ccnid].push generic: (id v), connector: c.from.connector, to: (id c.to), to-conn: c.to.connector\n        loop-list.push { generic: (id v), connector: v.connector, from: u.generic, from-conn: u.connector }\n\n    finished[cnid] = true\n\n  graph.nodes |> map (v) ->\n    (out-edges graph, v.id) |> map (c) ->\n      ccnid = (id c.to) + \":\" + c.to.connector\n      if (not (ccnid of pred))\n        dfs-recursive c.from , c.to\n\n  double-connection = (values pred) |> filter (c) ->\n    c.length == 2\n\n  generic-id = (dc) ->\n    conn_id = join \"_\", (words dc.0.to-conn)\n    dc.0.to + \"__\" + conn_id + \"CSPLoopControl\"\n\n  new-nodes = (double-connection) |> map (dc) ->\n    {\n      name: \"CSPLoopControl\",\n      id: generic-id dc,\n    }\n\n  connections = graph.connections |> filter (c) ->\n    not (double-connection |> any (dc) ->\n      dc.0.to == c.to.generic and dc.0.to-conn == c.to.connector)\n\n  new-connections = double-connection |> map (dc) ->\n    [\n      {\n        from: { generic: (generic-id dc), connector: \"OutStream\" }\n        to: {  generic: dc.0.to,  connector: dc.0.to-conn }\n        type: \"Normal\"\n      }\n      {\n        from: { generic: dc.0.generic, connector: dc.0.connector }\n        to: {  generic: (generic-id dc), connector: \"Initial\" }\n        type: \"Normal\"\n      }\n      {\n        from: { generic: dc.1.generic, connector: dc.1.connector }\n        to: { generic: (generic-id dc), connector: \"Stream\" }\n        type: \"Normal\"\n      }\n    ]\n\n  {\n    nodes: union graph.nodes, new-nodes\n    connections: union connections, (flatten new-connections)\n  }\n\nreturn (graph) ->\n  loops graph\n"}]}]};
